{"version":3,"file":"redux-toolkit.cjs.development.js","sources":["../src/devtoolsExtension.ts","../src/isPlainObject.ts","../src/utils.ts","../src/immutableStateInvariantMiddleware.ts","../src/serializableStateInvariantMiddleware.ts","../src/getDefaultMiddleware.ts","../src/configureStore.ts","../src/createAction.ts","../src/mapBuilders.ts","../src/createReducer.ts","../src/createSlice.ts","../src/entities/entity_state.ts","../src/entities/state_selectors.ts","../src/entities/state_adapter.ts","../src/entities/utils.ts","../src/entities/unsorted_state_adapter.ts","../src/entities/sorted_state_adapter.ts","../src/entities/create_adapter.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/nanoid.ts","../src/createAsyncThunk.ts","../src/index.ts"],"sourcesContent":["import { Action, ActionCreator, StoreEnhancer, compose } from 'redux'\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface EnhancerOptions {\r\n  /**\r\n   * the instance name to be showed on the monitor page. Default value is `document.title`.\r\n   * If not specified and there's no document title, it will consist of `tabId` and `instanceId`.\r\n   */\r\n  name?: string\r\n  /**\r\n   * action creators functions to be available in the Dispatcher.\r\n   */\r\n  actionCreators?: ActionCreator<any>[] | { [key: string]: ActionCreator<any> }\r\n  /**\r\n   * if more than one action is dispatched in the indicated interval, all new actions will be collected and sent at once.\r\n   * It is the joint between performance and speed. When set to `0`, all actions will be sent instantly.\r\n   * Set it to a higher value when experiencing perf issues (also `maxAge` to a lower value).\r\n   *\r\n   * @default 500 ms.\r\n   */\r\n  latency?: number\r\n  /**\r\n   * (> 1) - maximum allowed actions to be stored in the history tree. The oldest actions are removed once maxAge is reached. It's critical for performance.\r\n   *\r\n   * @default 50\r\n   */\r\n  maxAge?: number\r\n  /**\r\n   * - `undefined` - will use regular `JSON.stringify` to send data (it's the fast mode).\r\n   * - `false` - will handle also circular references.\r\n   * - `true` - will handle also date, regex, undefined, error objects, symbols, maps, sets and functions.\r\n   * - object, which contains `date`, `regex`, `undefined`, `error`, `symbol`, `map`, `set` and `function` keys.\r\n   *   For each of them you can indicate if to include (by setting as `true`).\r\n   *   For `function` key you can also specify a custom function which handles serialization.\r\n   *   See [`jsan`](https://github.com/kolodny/jsan) for more details.\r\n   */\r\n  serialize?:\r\n    | boolean\r\n    | {\r\n        date?: boolean\r\n        regex?: boolean\r\n        undefined?: boolean\r\n        error?: boolean\r\n        symbol?: boolean\r\n        map?: boolean\r\n        set?: boolean\r\n        function?: boolean | Function\r\n      }\r\n  /**\r\n   * function which takes `action` object and id number as arguments, and should return `action` object back.\r\n   */\r\n  actionSanitizer?: <A extends Action>(action: A, id: number) => A\r\n  /**\r\n   * function which takes `state` object and index as arguments, and should return `state` object back.\r\n   */\r\n  stateSanitizer?: <S>(state: S, index: number) => S\r\n  /**\r\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\r\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\r\n   */\r\n  actionsBlacklist?: string | string[]\r\n  /**\r\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\r\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\r\n   */\r\n  actionsWhitelist?: string | string[]\r\n  /**\r\n   * called for every action before sending, takes `state` and `action` object, and returns `true` in case it allows sending the current data to the monitor.\r\n   * Use it as a more advanced version of `actionsBlacklist`/`actionsWhitelist` parameters.\r\n   */\r\n  predicate?: <S, A extends Action>(state: S, action: A) => boolean\r\n  /**\r\n   * if specified as `false`, it will not record the changes till clicking on `Start recording` button.\r\n   * Available only for Redux enhancer, for others use `autoPause`.\r\n   *\r\n   * @default true\r\n   */\r\n  shouldRecordChanges?: boolean\r\n  /**\r\n   * if specified, whenever clicking on `Pause recording` button and there are actions in the history log, will add this action type.\r\n   * If not specified, will commit when paused. Available only for Redux enhancer.\r\n   *\r\n   * @default \"@@PAUSED\"\"\r\n   */\r\n  pauseActionType?: string\r\n  /**\r\n   * auto pauses when the extensionâ€™s window is not opened, and so has zero impact on your app when not in use.\r\n   * Not available for Redux enhancer (as it already does it but storing the data to be sent).\r\n   *\r\n   * @default false\r\n   */\r\n  autoPause?: boolean\r\n  /**\r\n   * if specified as `true`, it will not allow any non-monitor actions to be dispatched till clicking on `Unlock changes` button.\r\n   * Available only for Redux enhancer.\r\n   *\r\n   * @default false\r\n   */\r\n  shouldStartLocked?: boolean\r\n  /**\r\n   * if set to `false`, will not recompute the states on hot reloading (or on replacing the reducers). Available only for Redux enhancer.\r\n   *\r\n   * @default true\r\n   */\r\n  shouldHotReload?: boolean\r\n  /**\r\n   * if specified as `true`, whenever there's an exception in reducers, the monitors will show the error message, and next actions will not be dispatched.\r\n   *\r\n   * @default false\r\n   */\r\n  shouldCatchErrors?: boolean\r\n  /**\r\n   * If you want to restrict the extension, specify the features you allow.\r\n   * If not specified, all of the features are enabled. When set as an object, only those included as `true` will be allowed.\r\n   * Note that except `true`/`false`, `import` and `export` can be set as `custom` (which is by default for Redux enhancer), meaning that the importing/exporting occurs on the client side.\r\n   * Otherwise, you'll get/set the data right from the monitor part.\r\n   */\r\n  features?: {\r\n    /**\r\n     * start/pause recording of dispatched actions\r\n     */\r\n    pause?: boolean\r\n    /**\r\n     * lock/unlock dispatching actions and side effects\r\n     */\r\n    lock?: boolean\r\n    /**\r\n     * persist states on page reloading\r\n     */\r\n    persist?: boolean\r\n    /**\r\n     * export history of actions in a file\r\n     */\r\n    export?: boolean | 'custom'\r\n    /**\r\n     * import history of actions from a file\r\n     */\r\n    import?: boolean | 'custom'\r\n    /**\r\n     * jump back and forth (time travelling)\r\n     */\r\n    jump?: boolean\r\n    /**\r\n     * skip (cancel) actions\r\n     */\r\n    skip?: boolean\r\n    /**\r\n     * drag and drop actions in the history list\r\n     */\r\n    reorder?: boolean\r\n    /**\r\n     * dispatch custom actions or action creators\r\n     */\r\n    dispatch?: boolean\r\n    /**\r\n     * generate tests for the selected actions\r\n     */\r\n    test?: boolean\r\n  }\r\n  /**\r\n   * Set to true or a stacktrace-returning function to record call stack traces for dispatched actions.\r\n   * Defaults to false.\r\n   */\r\n  trace?: boolean | (<A extends Action>(action: A) => string)\r\n  /**\r\n   * The maximum number of stack trace entries to record per action. Defaults to 10.\r\n   */\r\n  traceLimit?: number\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport const composeWithDevTools: {\r\n  (options: EnhancerOptions): typeof compose\r\n  <StoreExt>(...funcs: Array<StoreEnhancer<StoreExt>>): StoreEnhancer<StoreExt>\r\n} =\r\n  typeof window !== 'undefined' &&\r\n  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\r\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\r\n    : function() {\r\n        if (arguments.length === 0) return undefined\r\n        if (typeof arguments[0] === 'object') return compose\r\n        return compose.apply(null, (arguments as any) as Function[])\r\n      }\r\n\r\n/**\r\n * @public\r\n */\r\nexport const devToolsEnhancer: {\r\n  (options: EnhancerOptions): StoreEnhancer<any>\r\n} =\r\n  typeof window !== 'undefined' && (window as any).__REDUX_DEVTOOLS_EXTENSION__\r\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION__\r\n    : function() {\r\n        return function(noop) {\r\n          return noop\r\n        }\r\n      }\r\n","/**\r\n * Returns true if the passed value is \"plain\" object, i.e. an object whose\r\n * protoype is the root `Object.prototype`. This includes objects created\r\n * using object literals, but not for instance for class instances.\r\n *\r\n * @param {any} value The value to inspect.\r\n * @returns {boolean} True if the argument appears to be a plain object.\r\n */\r\nexport default function isPlainObject(value: unknown): value is object {\r\n  if (typeof value !== 'object' || value === null) return false\r\n\r\n  let proto = value\r\n  while (Object.getPrototypeOf(proto) !== null) {\r\n    proto = Object.getPrototypeOf(proto)\r\n  }\r\n\r\n  return Object.getPrototypeOf(value) === proto\r\n}\r\n","export function getTimeMeasureUtils(maxDelay: number, fnName: string) {\r\n  let elapsed = 0\r\n  return {\r\n    measureTime<T>(fn: () => T): T {\r\n      const started = Date.now()\r\n      try {\r\n        return fn()\r\n      } finally {\r\n        const finished = Date.now()\r\n        elapsed += finished - started\r\n      }\r\n    },\r\n    warnIfExceeded() {\r\n      if (elapsed > maxDelay) {\r\n        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \r\nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\r\nIt is disabled in production builds, so you don't need to worry about that.`)\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Middleware } from 'redux'\r\nimport { getTimeMeasureUtils } from './utils'\r\n\r\ntype EntryProcessor = (key: string, value: any) => any\r\n\r\nconst isProduction: boolean = process.env.NODE_ENV === 'production'\r\nconst prefix: string = 'Invariant failed'\r\n\r\n// Throw an error if the condition fails\r\n// Strip out error messages for production\r\n// > Not providing an inline default argument for message as the result is smaller\r\nfunction invariant(condition: any, message?: string) {\r\n  if (condition) {\r\n    return\r\n  }\r\n  // Condition not passed\r\n\r\n  // In production we strip the message but still throw\r\n  if (isProduction) {\r\n    throw new Error(prefix)\r\n  }\r\n\r\n  // When not in production we allow the message to pass through\r\n  // *This block will be removed in production builds*\r\n  throw new Error(`${prefix}: ${message || ''}`)\r\n}\r\n\r\nfunction stringify(\r\n  obj: any,\r\n  serializer?: EntryProcessor,\r\n  indent?: string | number,\r\n  decycler?: EntryProcessor\r\n): string {\r\n  return JSON.stringify(obj, getSerialize(serializer, decycler), indent)\r\n}\r\n\r\nfunction getSerialize(\r\n  serializer?: EntryProcessor,\r\n  decycler?: EntryProcessor\r\n): EntryProcessor {\r\n  let stack: any[] = [],\r\n    keys: any[] = []\r\n\r\n  if (!decycler)\r\n    decycler = function(_: string, value: any) {\r\n      if (stack[0] === value) return '[Circular ~]'\r\n      return (\r\n        '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']'\r\n      )\r\n    }\r\n\r\n  return function(this: any, key: string, value: any) {\r\n    if (stack.length > 0) {\r\n      var thisPos = stack.indexOf(this)\r\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\r\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\r\n      if (~stack.indexOf(value)) value = decycler!.call(this, key, value)\r\n    } else stack.push(value)\r\n\r\n    return serializer == null ? value : serializer.call(this, key, value)\r\n  }\r\n}\r\n\r\n/**\r\n * The default `isImmutable` function.\r\n *\r\n * @public\r\n */\r\nexport function isImmutableDefault(value: unknown): boolean {\r\n  return (\r\n    typeof value !== 'object' || value === null || typeof value === 'undefined'\r\n  )\r\n}\r\n\r\nexport function trackForMutations(\r\n  isImmutable: IsImmutableFunc,\r\n  ignorePaths: string[] | undefined,\r\n  obj: any\r\n) {\r\n  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj)\r\n  return {\r\n    detectMutations() {\r\n      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj)\r\n    }\r\n  }\r\n}\r\n\r\ninterface TrackedProperty {\r\n  value: any\r\n  children: Record<string, any>\r\n}\r\n\r\nfunction trackProperties(\r\n  isImmutable: IsImmutableFunc,\r\n  ignorePaths: IgnorePaths = [],\r\n  obj: Record<string, any>,\r\n  path: string[] = []\r\n) {\r\n  const tracked: Partial<TrackedProperty> = { value: obj }\r\n\r\n  if (!isImmutable(obj)) {\r\n    tracked.children = {}\r\n\r\n    for (const key in obj) {\r\n      const childPath = path.concat(key)\r\n      if (\r\n        ignorePaths.length &&\r\n        ignorePaths.indexOf(childPath.join('.')) !== -1\r\n      ) {\r\n        continue\r\n      }\r\n\r\n      tracked.children[key] = trackProperties(\r\n        isImmutable,\r\n        ignorePaths,\r\n        obj[key],\r\n        childPath\r\n      )\r\n    }\r\n  }\r\n  return tracked as TrackedProperty\r\n}\r\n\r\ntype IgnorePaths = string[]\r\n\r\nfunction detectMutations(\r\n  isImmutable: IsImmutableFunc,\r\n  ignorePaths: IgnorePaths = [],\r\n  trackedProperty: TrackedProperty,\r\n  obj: any,\r\n  sameParentRef: boolean = false,\r\n  path: string[] = []\r\n): { wasMutated: boolean; path?: string[] } {\r\n  const prevObj = trackedProperty ? trackedProperty.value : undefined\r\n\r\n  const sameRef = prevObj === obj\r\n\r\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\r\n    return { wasMutated: true, path }\r\n  }\r\n\r\n  if (isImmutable(prevObj) || isImmutable(obj)) {\r\n    return { wasMutated: false }\r\n  }\r\n\r\n  // Gather all keys from prev (tracked) and after objs\r\n  const keysToDetect: Record<string, boolean> = {}\r\n  Object.keys(trackedProperty.children).forEach(key => {\r\n    keysToDetect[key] = true\r\n  })\r\n  Object.keys(obj).forEach(key => {\r\n    keysToDetect[key] = true\r\n  })\r\n\r\n  const keys = Object.keys(keysToDetect)\r\n  for (let i = 0; i < keys.length; i++) {\r\n    const key = keys[i]\r\n    const childPath = path.concat(key)\r\n    if (ignorePaths.length && ignorePaths.indexOf(childPath.join('.')) !== -1) {\r\n      continue\r\n    }\r\n\r\n    const result = detectMutations(\r\n      isImmutable,\r\n      ignorePaths,\r\n      trackedProperty.children[key],\r\n      obj[key],\r\n      sameRef,\r\n      childPath\r\n    )\r\n\r\n    if (result.wasMutated) {\r\n      return result\r\n    }\r\n  }\r\n  return { wasMutated: false }\r\n}\r\n\r\ntype IsImmutableFunc = (value: any) => boolean\r\n\r\n/**\r\n * Options for `createImmutableStateInvariantMiddleware()`.\r\n *\r\n * @public\r\n */\r\nexport interface ImmutableStateInvariantMiddlewareOptions {\r\n  isImmutable?: IsImmutableFunc\r\n  ignoredPaths?: string[]\r\n  warnAfter?: number\r\n  ignore?: string[] // @deprecated. Use ignoredPaths\r\n}\r\n\r\n/**\r\n * Creates a middleware that checks whether any state was mutated in between\r\n * dispatches or during a dispatch. If any mutations are detected, an error is\r\n * thrown.\r\n *\r\n * @param options Middleware options.\r\n *\r\n * @public\r\n */\r\nexport function createImmutableStateInvariantMiddleware(\r\n  options: ImmutableStateInvariantMiddlewareOptions = {}\r\n): Middleware {\r\n  if (process.env.NODE_ENV === 'production') {\r\n    return () => next => action => next(action)\r\n  }\r\n\r\n  let {\r\n    isImmutable = isImmutableDefault,\r\n    ignoredPaths,\r\n    warnAfter = 32,\r\n    ignore\r\n  } = options\r\n\r\n  // Alias ignore->ignoredPaths, but prefer ignoredPaths if present\r\n  ignoredPaths = ignoredPaths || ignore\r\n\r\n  const track = trackForMutations.bind(null, isImmutable, ignoredPaths)\r\n\r\n  return ({ getState }) => {\r\n    let state = getState()\r\n    let tracker = track(state)\r\n\r\n    let result\r\n    return next => action => {\r\n      const measureUtils = getTimeMeasureUtils(\r\n        warnAfter,\r\n        'ImmutableStateInvariantMiddleware'\r\n      )\r\n\r\n      measureUtils.measureTime(() => {\r\n        state = getState()\r\n\r\n        result = tracker.detectMutations()\r\n        // Track before potentially not meeting the invariant\r\n        tracker = track(state)\r\n\r\n        invariant(\r\n          !result.wasMutated,\r\n          `A state mutation was detected between dispatches, in the path '${(\r\n            result.path || []\r\n          ).join(\r\n            '.'\r\n          )}'.  This may cause incorrect behavior. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\r\n        )\r\n      })\r\n\r\n      const dispatchedAction = next(action)\r\n\r\n      measureUtils.measureTime(() => {\r\n        state = getState()\r\n\r\n        result = tracker.detectMutations()\r\n        // Track before potentially not meeting the invariant\r\n        tracker = track(state)\r\n\r\n        result.wasMutated &&\r\n          invariant(\r\n            !result.wasMutated,\r\n            `A state mutation was detected inside a dispatch, in the path: ${(\r\n              result.path || []\r\n            ).join(\r\n              '.'\r\n            )}. Take a look at the reducer(s) handling the action ${stringify(\r\n              action\r\n            )}. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\r\n          )\r\n      })\r\n\r\n      measureUtils.warnIfExceeded()\r\n\r\n      return dispatchedAction\r\n    }\r\n  }\r\n}\r\n","import isPlainObject from './isPlainObject'\r\nimport { Middleware } from 'redux'\r\nimport { getTimeMeasureUtils } from './utils'\r\n\r\n/**\r\n * Returns true if the passed value is \"plain\", i.e. a value that is either\r\n * directly JSON-serializable (boolean, number, string, array, plain object)\r\n * or `undefined`.\r\n *\r\n * @param val The value to check.\r\n *\r\n * @public\r\n */\r\nexport function isPlain(val: any) {\r\n  return (\r\n    typeof val === 'undefined' ||\r\n    val === null ||\r\n    typeof val === 'string' ||\r\n    typeof val === 'boolean' ||\r\n    typeof val === 'number' ||\r\n    Array.isArray(val) ||\r\n    isPlainObject(val)\r\n  )\r\n}\r\n\r\ninterface NonSerializableValue {\r\n  keyPath: string\r\n  value: unknown\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport function findNonSerializableValue(\r\n  value: unknown,\r\n  path: ReadonlyArray<string> = [],\r\n  isSerializable: (value: unknown) => boolean = isPlain,\r\n  getEntries?: (value: unknown) => [string, any][],\r\n  ignoredPaths: string[] = []\r\n): NonSerializableValue | false {\r\n  let foundNestedSerializable: NonSerializableValue | false\r\n\r\n  if (!isSerializable(value)) {\r\n    return {\r\n      keyPath: path.join('.') || '<root>',\r\n      value: value\r\n    }\r\n  }\r\n\r\n  if (typeof value !== 'object' || value === null) {\r\n    return false\r\n  }\r\n\r\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\r\n\r\n  const hasIgnoredPaths = ignoredPaths.length > 0\r\n\r\n  for (const [property, nestedValue] of entries) {\r\n    const nestedPath = path.concat(property)\r\n\r\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\r\n      continue\r\n    }\r\n\r\n    if (!isSerializable(nestedValue)) {\r\n      return {\r\n        keyPath: nestedPath.join('.'),\r\n        value: nestedValue\r\n      }\r\n    }\r\n\r\n    if (typeof nestedValue === 'object') {\r\n      foundNestedSerializable = findNonSerializableValue(\r\n        nestedValue,\r\n        nestedPath,\r\n        isSerializable,\r\n        getEntries,\r\n        ignoredPaths\r\n      )\r\n\r\n      if (foundNestedSerializable) {\r\n        return foundNestedSerializable\r\n      }\r\n    }\r\n  }\r\n\r\n  return false\r\n}\r\n\r\n/**\r\n * Options for `createSerializableStateInvariantMiddleware()`.\r\n *\r\n * @public\r\n */\r\nexport interface SerializableStateInvariantMiddlewareOptions {\r\n  /**\r\n   * The function to check if a value is considered serializable. This\r\n   * function is applied recursively to every value contained in the\r\n   * state. Defaults to `isPlain()`.\r\n   */\r\n  isSerializable?: (value: any) => boolean\r\n  /**\r\n   * The function that will be used to retrieve entries from each\r\n   * value.  If unspecified, `Object.entries` will be used. Defaults\r\n   * to `undefined`.\r\n   */\r\n  getEntries?: (value: any) => [string, any][]\r\n\r\n  /**\r\n   * An array of action types to ignore when checking for serializability, Defaults to []\r\n   */\r\n  ignoredActions?: string[]\r\n\r\n  /**\r\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to ['meta.arg']\r\n   */\r\n  ignoredActionPaths?: string[]\r\n\r\n  /**\r\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\r\n   */\r\n  ignoredPaths?: string[]\r\n  /**\r\n   * Execution time warning threshold. If the middleware takes longer than `warnAfter` ms, a warning will be displayed in the console. Defaults to 32\r\n   */\r\n  warnAfter?: number\r\n}\r\n\r\n/**\r\n * Creates a middleware that, after every state change, checks if the new\r\n * state is serializable. If a non-serializable value is found within the\r\n * state, an error is printed to the console.\r\n *\r\n * @param options Middleware options.\r\n *\r\n * @public\r\n */\r\nexport function createSerializableStateInvariantMiddleware(\r\n  options: SerializableStateInvariantMiddlewareOptions = {}\r\n): Middleware {\r\n  if (process.env.NODE_ENV === 'production') {\r\n    return () => next => action => next(action)\r\n  }\r\n  const {\r\n    isSerializable = isPlain,\r\n    getEntries,\r\n    ignoredActions = [],\r\n    ignoredActionPaths = ['meta.arg'],\r\n    ignoredPaths = [],\r\n    warnAfter = 32\r\n  } = options\r\n\r\n  return storeAPI => next => action => {\r\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\r\n      return next(action)\r\n    }\r\n\r\n    const measureUtils = getTimeMeasureUtils(\r\n      warnAfter,\r\n      'SerializableStateInvariantMiddleware'\r\n    )\r\n    measureUtils.measureTime(() => {\r\n      const foundActionNonSerializableValue = findNonSerializableValue(\r\n        action,\r\n        [],\r\n        isSerializable,\r\n        getEntries,\r\n        ignoredActionPaths\r\n      )\r\n\r\n      if (foundActionNonSerializableValue) {\r\n        const { keyPath, value } = foundActionNonSerializableValue\r\n\r\n        console.error(\r\n          `A non-serializable value was detected in an action, in the path: \\`${keyPath}\\`. Value:`,\r\n          value,\r\n          '\\nTake a look at the logic that dispatched this action: ',\r\n          action,\r\n          '\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\r\n        )\r\n      }\r\n    })\r\n\r\n    const result = next(action)\r\n\r\n    measureUtils.measureTime(() => {\r\n      const state = storeAPI.getState()\r\n\r\n      const foundStateNonSerializableValue = findNonSerializableValue(\r\n        state,\r\n        [],\r\n        isSerializable,\r\n        getEntries,\r\n        ignoredPaths\r\n      )\r\n\r\n      if (foundStateNonSerializableValue) {\r\n        const { keyPath, value } = foundStateNonSerializableValue\r\n\r\n        console.error(\r\n          `A non-serializable value was detected in the state, in the path: \\`${keyPath}\\`. Value:`,\r\n          value,\r\n          `\r\nTake a look at the reducer(s) handling this action type: ${action.type}.\r\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\r\n        )\r\n      }\r\n    })\r\n\r\n    measureUtils.warnIfExceeded()\r\n\r\n    return result\r\n  }\r\n}\r\n","import { Middleware, AnyAction } from 'redux'\r\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\r\nimport {\r\n  /* PROD_START_REMOVE_UMD */\r\n  createImmutableStateInvariantMiddleware,\r\n  /* PROD_STOP_REMOVE_UMD */\r\n  ImmutableStateInvariantMiddlewareOptions\r\n} from './immutableStateInvariantMiddleware'\r\n\r\nimport {\r\n  createSerializableStateInvariantMiddleware,\r\n  SerializableStateInvariantMiddlewareOptions\r\n} from './serializableStateInvariantMiddleware'\r\n\r\nfunction isBoolean(x: any): x is boolean {\r\n  return typeof x === 'boolean'\r\n}\r\n\r\ninterface ThunkOptions<E = any> {\r\n  extraArgument: E\r\n}\r\n\r\ninterface GetDefaultMiddlewareOptions {\r\n  thunk?: boolean | ThunkOptions\r\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\r\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\r\n}\r\n\r\nexport type ThunkMiddlewareFor<\r\n  S,\r\n  O extends GetDefaultMiddlewareOptions = {}\r\n> = O extends {\r\n  thunk: false\r\n}\r\n  ? never\r\n  : O extends { thunk: { extraArgument: infer E } }\r\n  ? ThunkMiddleware<S, AnyAction, E>\r\n  :\r\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\r\n      | ThunkMiddleware<S, AnyAction>\r\n\r\n/**\r\n * Returns any array containing the default middleware installed by\r\n * `configureStore()`. Useful if you want to configure your store with a custom\r\n * `middleware` array but still keep the default set.\r\n *\r\n * @return The default middleware used by `configureStore()`.\r\n *\r\n * @public\r\n */\r\nexport function getDefaultMiddleware<\r\n  S = any,\r\n  O extends Partial<GetDefaultMiddlewareOptions> = {\r\n    thunk: true\r\n    immutableCheck: true\r\n    serializableCheck: true\r\n  }\r\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\r\n  const {\r\n    thunk = true,\r\n    immutableCheck = true,\r\n    serializableCheck = true\r\n  } = options\r\n\r\n  let middlewareArray: Middleware<{}, S>[] = []\r\n\r\n  if (thunk) {\r\n    if (isBoolean(thunk)) {\r\n      middlewareArray.push(thunkMiddleware)\r\n    } else {\r\n      middlewareArray.push(\r\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\r\n      )\r\n    }\r\n  }\r\n\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (immutableCheck) {\r\n      /* PROD_START_REMOVE_UMD */\r\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\r\n\r\n      if (!isBoolean(immutableCheck)) {\r\n        immutableOptions = immutableCheck\r\n      }\r\n\r\n      middlewareArray.unshift(\r\n        createImmutableStateInvariantMiddleware(immutableOptions)\r\n      )\r\n      /* PROD_STOP_REMOVE_UMD */\r\n    }\r\n\r\n    if (serializableCheck) {\r\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\r\n\r\n      if (!isBoolean(serializableCheck)) {\r\n        serializableOptions = serializableCheck\r\n      }\r\n\r\n      middlewareArray.push(\r\n        createSerializableStateInvariantMiddleware(serializableOptions)\r\n      )\r\n    }\r\n  }\r\n\r\n  return middlewareArray as any\r\n}\r\n","import {\r\n  createStore,\r\n  compose,\r\n  applyMiddleware,\r\n  combineReducers,\r\n  Reducer,\r\n  ReducersMapObject,\r\n  Middleware,\r\n  Action,\r\n  AnyAction,\r\n  StoreEnhancer,\r\n  Store,\r\n  DeepPartial,\r\n  Dispatch\r\n} from 'redux'\r\nimport {\r\n  composeWithDevTools,\r\n  EnhancerOptions as DevToolsOptions\r\n} from './devtoolsExtension'\r\n\r\nimport isPlainObject from './isPlainObject'\r\nimport {\r\n  getDefaultMiddleware,\r\n  ThunkMiddlewareFor\r\n} from './getDefaultMiddleware'\r\nimport { DispatchForMiddlewares } from './tsHelpers'\r\n\r\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\r\n\r\n/**\r\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\r\n *\r\n * @public\r\n */\r\nexport type ConfigureEnhancersCallback = (\r\n  defaultEnhancers: StoreEnhancer[]\r\n) => StoreEnhancer[]\r\n\r\n/**\r\n * Options for `configureStore()`.\r\n *\r\n * @public\r\n */\r\nexport interface ConfigureStoreOptions<\r\n  S = any,\r\n  A extends Action = AnyAction,\r\n  M extends Middlewares<S> = Middlewares<S>\r\n> {\r\n  /**\r\n   * A single reducer function that will be used as the root reducer, or an\r\n   * object of slice reducers that will be passed to `combineReducers()`.\r\n   */\r\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\r\n\r\n  /**\r\n   * An array of Redux middleware to install. If not supplied, defaults to\r\n   * the set of middleware returned by `getDefaultMiddleware()`.\r\n   */\r\n  middleware?: M\r\n\r\n  /**\r\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\r\n   *\r\n   * Additional configuration can be done by passing Redux DevTools options\r\n   */\r\n  devTools?: boolean | DevToolsOptions\r\n\r\n  /**\r\n   * The initial state, same as Redux's createStore.\r\n   * You may optionally specify it to hydrate the state\r\n   * from the server in universal apps, or to restore a previously serialized\r\n   * user session. If you use `combineReducers()` to produce the root reducer\r\n   * function (either directly or indirectly by passing an object as `reducer`),\r\n   * this must be an object with the same shape as the reducer map keys.\r\n   */\r\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\r\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\r\n  // based on the value passed as `preloadedState`, which might be a partial\r\n  // state rather than the full thing.\r\n  preloadedState?: DeepPartial<S extends any ? S : S>\r\n\r\n  /**\r\n   * The store enhancers to apply. See Redux's `createStore()`.\r\n   * All enhancers will be included before the DevTools Extension enhancer.\r\n   * If you need to customize the order of enhancers, supply a callback\r\n   * function that will receive the original array (ie, `[applyMiddleware]`),\r\n   * and should return a new array (such as `[applyMiddleware, offline]`).\r\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\r\n   */\r\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\r\n}\r\n\r\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\r\n\r\n/**\r\n * A Redux store returned by `configureStore()`. Supports dispatching\r\n * side-effectful _thunks_ in addition to plain actions.\r\n *\r\n * @public\r\n */\r\nexport interface EnhancedStore<\r\n  S = any,\r\n  A extends Action = AnyAction,\r\n  M extends Middlewares<S> = Middlewares<S>\r\n> extends Store<S, A> {\r\n  /**\r\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\r\n   *\r\n   * @inheritdoc\r\n   */\r\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\r\n}\r\n\r\n/**\r\n * A friendly abstraction over the standard Redux `createStore()` function.\r\n *\r\n * @param config The store configuration.\r\n * @returns A configured Redux store.\r\n *\r\n * @public\r\n */\r\nexport function configureStore<\r\n  S = any,\r\n  A extends Action = AnyAction,\r\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\r\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\r\n  const {\r\n    reducer = undefined,\r\n    middleware = getDefaultMiddleware(),\r\n    devTools = true,\r\n    preloadedState = undefined,\r\n    enhancers = undefined\r\n  } = options || {}\r\n\r\n  let rootReducer: Reducer<S, A>\r\n\r\n  if (typeof reducer === 'function') {\r\n    rootReducer = reducer\r\n  } else if (isPlainObject(reducer)) {\r\n    rootReducer = combineReducers(reducer)\r\n  } else {\r\n    throw new Error(\r\n      '\"reducer\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\r\n    )\r\n  }\r\n\r\n  const middlewareEnhancer = applyMiddleware(...middleware)\r\n\r\n  let finalCompose = compose\r\n\r\n  if (devTools) {\r\n    finalCompose = composeWithDevTools({\r\n      // Enable capture of stack traces for dispatched Redux actions\r\n      trace: !IS_PRODUCTION,\r\n      ...(typeof devTools === 'object' && devTools)\r\n    })\r\n  }\r\n\r\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\r\n\r\n  if (Array.isArray(enhancers)) {\r\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\r\n  } else if (typeof enhancers === 'function') {\r\n    storeEnhancers = enhancers(storeEnhancers)\r\n  }\r\n\r\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\r\n\r\n  return createStore(\r\n    rootReducer,\r\n    preloadedState as DeepPartial<S>,\r\n    composedEnhancer\r\n  )\r\n}\r\n","import { Action } from 'redux'\r\nimport {\r\n  IsUnknownOrNonInferrable,\r\n  IfMaybeUndefined,\r\n  IfVoid,\r\n  IsAny\r\n} from './tsHelpers'\r\nimport isPlainObject from './isPlainObject'\r\n\r\n/**\r\n * An action with a string type and an associated payload. This is the\r\n * type of action returned by `createAction()` action creators.\r\n *\r\n * @template P The type of the action's payload.\r\n * @template T the type used for the action type.\r\n * @template M The type of the action's meta (optional)\r\n * @template E The type of the action's error (optional)\r\n *\r\n * @public\r\n */\r\nexport type PayloadAction<\r\n  P = void,\r\n  T extends string = string,\r\n  M = never,\r\n  E = never\r\n> = {\r\n  payload: P\r\n  type: T\r\n} & ([M] extends [never]\r\n  ? {}\r\n  : {\r\n      meta: M\r\n    }) &\r\n  ([E] extends [never]\r\n    ? {}\r\n    : {\r\n        error: E\r\n      })\r\n\r\n/**\r\n * A \"prepare\" method to be used as the second parameter of `createAction`.\r\n * Takes any number of arguments and returns a Flux Standard Action without\r\n * type (will be added later) that *must* contain a payload (might be undefined).\r\n *\r\n * @public\r\n */\r\nexport type PrepareAction<P> =\r\n  | ((...args: any[]) => { payload: P })\r\n  | ((...args: any[]) => { payload: P; meta: any })\r\n  | ((...args: any[]) => { payload: P; error: any })\r\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\r\n\r\n/**\r\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\r\n *\r\n * @internal\r\n */\r\nexport type _ActionCreatorWithPreparedPayload<\r\n  PA extends PrepareAction<any> | void,\r\n  T extends string = string\r\n> = PA extends PrepareAction<infer P>\r\n  ? ActionCreatorWithPreparedPayload<\r\n      Parameters<PA>,\r\n      P,\r\n      T,\r\n      ReturnType<PA> extends {\r\n        error: infer E\r\n      }\r\n        ? E\r\n        : never,\r\n      ReturnType<PA> extends {\r\n        meta: infer M\r\n      }\r\n        ? M\r\n        : never\r\n    >\r\n  : void\r\n\r\n/**\r\n * Basic type for all action creators.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n */\r\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\r\n  type: T\r\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\r\n}\r\n\r\n/**\r\n * An action creator that takes multiple arguments that are passed\r\n * to a `PrepareAction` method to create the final Action.\r\n * @typeParam Args arguments for the action creator function\r\n * @typeParam P `payload` type\r\n * @typeParam T `type` name\r\n * @typeParam E optional `error` type\r\n * @typeParam M optional `meta` type\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithPreparedPayload<\r\n  Args extends unknown[],\r\n  P,\r\n  T extends string = string,\r\n  E = never,\r\n  M = never\r\n> extends BaseActionCreator<P, T, M, E> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} with `Args` will return\r\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\r\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\r\n   */\r\n  (...args: Args): PayloadAction<P, T, M, E>\r\n}\r\n\r\n/**\r\n * An action creator of type `T` that takes an optional payload of type `P`.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\r\n  extends BaseActionCreator<P, T> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} with an argument will\r\n   * return a {@link PayloadAction} of type `T` with a payload of `P`.\r\n   * Calling it without an argument will return a PayloadAction with a payload of `undefined`.\r\n   */\r\n  (payload?: P): PayloadAction<P, T>\r\n}\r\n\r\n/**\r\n * An action creator of type `T` that takes no payload.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithoutPayload<T extends string = string>\r\n  extends BaseActionCreator<undefined, T> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} will\r\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\r\n   */\r\n  (): PayloadAction<undefined, T>\r\n}\r\n\r\n/**\r\n * An action creator of type `T` that requires a payload of type P.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithPayload<P, T extends string = string>\r\n  extends BaseActionCreator<P, T> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} with an argument will\r\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\r\n   */\r\n  (payload: P): PayloadAction<P, T>\r\n}\r\n\r\n/**\r\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\r\n *\r\n * @inheritdoc {redux#ActionCreator}\r\n *\r\n * @public\r\n */\r\nexport interface ActionCreatorWithNonInferrablePayload<\r\n  T extends string = string\r\n> extends BaseActionCreator<unknown, T> {\r\n  /**\r\n   * Calling this {@link redux#ActionCreator} with an argument will\r\n   * return a {@link PayloadAction} of type `T` with a payload\r\n   * of exactly the type of the argument.\r\n   */\r\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\r\n}\r\n\r\n/**\r\n * An action creator that produces actions with a `payload` attribute.\r\n *\r\n * @typeParam P the `payload` type\r\n * @typeParam T the `type` of the resulting action\r\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\r\n *\r\n * @public\r\n */\r\nexport type PayloadActionCreator<\r\n  P = void,\r\n  T extends string = string,\r\n  PA extends PrepareAction<P> | void = void\r\n> = IfPrepareActionMethodProvided<\r\n  PA,\r\n  _ActionCreatorWithPreparedPayload<PA, T>,\r\n  // else\r\n  IsAny<\r\n    P,\r\n    ActionCreatorWithPayload<any, T>,\r\n    IsUnknownOrNonInferrable<\r\n      P,\r\n      ActionCreatorWithNonInferrablePayload<T>,\r\n      // else\r\n      IfVoid<\r\n        P,\r\n        ActionCreatorWithoutPayload<T>,\r\n        // else\r\n        IfMaybeUndefined<\r\n          P,\r\n          ActionCreatorWithOptionalPayload<P, T>,\r\n          // else\r\n          ActionCreatorWithPayload<P, T>\r\n        >\r\n      >\r\n    >\r\n  >\r\n>\r\n\r\n/**\r\n * A utility function to create an action creator for the given action type\r\n * string. The action creator accepts a single argument, which will be included\r\n * in the action object as a field called payload. The action creator function\r\n * will also have its toString() overriden so that it returns the action type,\r\n * allowing it to be used in reducer logic that is looking for that action type.\r\n *\r\n * @param type The action type to use for created actions.\r\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\r\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\r\n *\r\n * @public\r\n */\r\nexport function createAction<P = void, T extends string = string>(\r\n  type: T\r\n): PayloadActionCreator<P, T>\r\n\r\n/**\r\n * A utility function to create an action creator for the given action type\r\n * string. The action creator accepts a single argument, which will be included\r\n * in the action object as a field called payload. The action creator function\r\n * will also have its toString() overriden so that it returns the action type,\r\n * allowing it to be used in reducer logic that is looking for that action type.\r\n *\r\n * @param type The action type to use for created actions.\r\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\r\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\r\n *\r\n * @public\r\n */\r\nexport function createAction<\r\n  PA extends PrepareAction<any>,\r\n  T extends string = string\r\n>(\r\n  type: T,\r\n  prepareAction: PA\r\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\r\n\r\nexport function createAction(type: string, prepareAction?: Function): any {\r\n  function actionCreator(...args: any[]) {\r\n    if (prepareAction) {\r\n      let prepared = prepareAction(...args)\r\n      if (!prepared) {\r\n        throw new Error('prepareAction did not return an object')\r\n      }\r\n\r\n      return {\r\n        type,\r\n        payload: prepared.payload,\r\n        ...('meta' in prepared && { meta: prepared.meta }),\r\n        ...('error' in prepared && { error: prepared.error })\r\n      }\r\n    }\r\n    return { type, payload: args[0] }\r\n  }\r\n\r\n  actionCreator.toString = () => `${type}`\r\n\r\n  actionCreator.type = type\r\n\r\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\r\n    action.type === type\r\n\r\n  return actionCreator\r\n}\r\n\r\nexport function isFSA(\r\n  action: unknown\r\n): action is {\r\n  type: string\r\n  payload?: unknown\r\n  error?: unknown\r\n  meta?: unknown\r\n} {\r\n  return (\r\n    isPlainObject(action) &&\r\n    typeof (action as any).type === 'string' &&\r\n    Object.keys(action).every(isValidKey)\r\n  )\r\n}\r\n\r\nfunction isValidKey(key: string) {\r\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\r\n}\r\n\r\n/**\r\n * Returns the action type of the actions created by the passed\r\n * `createAction()`-generated action creator (arbitrary action creators\r\n * are not supported).\r\n *\r\n * @param action The action creator whose action type to get.\r\n * @returns The action type used by the action creator.\r\n *\r\n * @public\r\n */\r\nexport function getType<T extends string>(\r\n  actionCreator: PayloadActionCreator<any, T>\r\n): T {\r\n  return `${actionCreator}` as T\r\n}\r\n\r\n// helper types for more readable typings\r\n\r\ntype IfPrepareActionMethodProvided<\r\n  PA extends PrepareAction<any> | void,\r\n  True,\r\n  False\r\n> = PA extends (...args: any[]) => any ? True : False\r\n","import { Action } from 'redux'\r\nimport { CaseReducer, CaseReducers } from './createReducer'\r\n\r\nexport interface TypedActionCreator<Type extends string> {\r\n  (...args: any[]): Action<Type>\r\n  type: Type\r\n}\r\n\r\n/**\r\n * A builder for an action <-> reducer map.\r\n *\r\n * @public\r\n */\r\nexport interface ActionReducerMapBuilder<State> {\r\n  /**\r\n   * Add a case reducer for actions created by this action creator.\r\n   * @param actionCreator\r\n   * @param reducer\r\n   */\r\n  addCase<ActionCreator extends TypedActionCreator<string>>(\r\n    actionCreator: ActionCreator,\r\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\r\n  ): ActionReducerMapBuilder<State>\r\n  /**\r\n   * Add a case reducer for actions with the specified type.\r\n   * @param type\r\n   * @param reducer\r\n   */\r\n  addCase<Type extends string, A extends Action<Type>>(\r\n    type: Type,\r\n    reducer: CaseReducer<State, A>\r\n  ): ActionReducerMapBuilder<State>\r\n}\r\n\r\nexport function executeReducerBuilderCallback<S>(\r\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\r\n): CaseReducers<S, any> {\r\n  const actionsMap: CaseReducers<S, any> = {}\r\n  const builder = {\r\n    addCase(\r\n      typeOrActionCreator: string | TypedActionCreator<any>,\r\n      reducer: CaseReducer<S>\r\n    ) {\r\n      const type =\r\n        typeof typeOrActionCreator === 'string'\r\n          ? typeOrActionCreator\r\n          : typeOrActionCreator.type\r\n      if (type in actionsMap) {\r\n        throw new Error(\r\n          'addCase cannot be called with two reducers for the same action type'\r\n        )\r\n      }\r\n      actionsMap[type] = reducer\r\n      return builder\r\n    }\r\n  }\r\n  builderCallback(builder)\r\n  return actionsMap\r\n}\r\n","import createNextState, { Draft } from 'immer'\r\nimport { AnyAction, Action, Reducer } from 'redux'\r\nimport {\r\n  executeReducerBuilderCallback,\r\n  ActionReducerMapBuilder\r\n} from './mapBuilders'\r\n\r\n/**\r\n * Defines a mapping from action types to corresponding action object shapes.\r\n *\r\n * @deprecated This should not be used manually - it is only used for internal\r\n *             inference purposes and should not have any further value.\r\n *             It might be removed in the future.\r\n * @public\r\n */\r\nexport type Actions<T extends keyof any = string> = Record<T, Action>\r\n\r\n/**\r\n * An *case reducer* is a reducer function for a specific action type. Case\r\n * reducers can be composed to full reducers using `createReducer()`.\r\n *\r\n * Unlike a normal Redux reducer, a case reducer is never called with an\r\n * `undefined` state to determine the initial state. Instead, the initial\r\n * state is explicitly specified as an argument to `createReducer()`.\r\n *\r\n * In addition, a case reducer can choose to mutate the passed-in `state`\r\n * value directly instead of returning a new state. This does not actually\r\n * cause the store state to be mutated directly; instead, thanks to\r\n * [immer](https://github.com/mweststrate/immer), the mutations are\r\n * translated to copy operations that result in a new state.\r\n *\r\n * @public\r\n */\r\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\r\n  state: Draft<S>,\r\n  action: A\r\n) => S | void\r\n\r\n/**\r\n * A mapping from action types to case reducers for `createReducer()`.\r\n *\r\n * @deprecated This should not be used manually - it is only used\r\n *             for internal inference purposes and using it manually\r\n *             would lead to type erasure.\r\n *             It might be removed in the future.\r\n * @public\r\n */\r\nexport type CaseReducers<S, AS extends Actions> = {\r\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\r\n}\r\n\r\n/**\r\n * A utility function that allows defining a reducer as a mapping from action\r\n * type to *case reducer* functions that handle these action types. The\r\n * reducer's initial state is passed as the first argument.\r\n *\r\n * The body of every case reducer is implicitly wrapped with a call to\r\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\r\n * This means that rather than returning a new state object, you can also\r\n * mutate the passed-in state object directly; these mutations will then be\r\n * automatically and efficiently translated into copies, giving you both\r\n * convenience and immutability.\r\n *\r\n * @param initialState The initial state to be returned by the reducer.\r\n * @param actionsMap A mapping from action types to action-type-specific\r\n *   case reducers.\r\n *\r\n * @public\r\n */\r\nexport function createReducer<\r\n  S,\r\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\r\n>(initialState: S, actionsMap: CR): Reducer<S>\r\n/**\r\n * A utility function that allows defining a reducer as a mapping from action\r\n * type to *case reducer* functions that handle these action types. The\r\n * reducer's initial state is passed as the first argument.\r\n *\r\n * The body of every case reducer is implicitly wrapped with a call to\r\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\r\n * This means that rather than returning a new state object, you can also\r\n * mutate the passed-in state object directly; these mutations will then be\r\n * automatically and efficiently translated into copies, giving you both\r\n * convenience and immutability.\r\n * @param initialState The initial state to be returned by the reducer.\r\n * @param builderCallback A callback that receives a *builder* object to define\r\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\r\n *\r\n * @public\r\n */\r\nexport function createReducer<S>(\r\n  initialState: S,\r\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\r\n): Reducer<S>\r\n\r\nexport function createReducer<S>(\r\n  initialState: S,\r\n  mapOrBuilderCallback:\r\n    | CaseReducers<S, any>\r\n    | ((builder: ActionReducerMapBuilder<S>) => void)\r\n): Reducer<S> {\r\n  let actionsMap =\r\n    typeof mapOrBuilderCallback === 'function'\r\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\r\n      : mapOrBuilderCallback\r\n\r\n  return function(state = initialState, action): S {\r\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\r\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\r\n    // these two types.\r\n    return createNextState(state, (draft: Draft<S>) => {\r\n      const caseReducer = actionsMap[action.type]\r\n      return caseReducer ? caseReducer(draft, action) : undefined\r\n    })\r\n  }\r\n}\r\n","import { Reducer } from 'redux'\r\nimport {\r\n  ActionCreatorWithoutPayload,\r\n  createAction,\r\n  PayloadAction,\r\n  PayloadActionCreator,\r\n  PrepareAction,\r\n  _ActionCreatorWithPreparedPayload\r\n} from './createAction'\r\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\r\nimport {\r\n  ActionReducerMapBuilder,\r\n  executeReducerBuilderCallback\r\n} from './mapBuilders'\r\nimport { Omit } from './tsHelpers'\r\n\r\n/**\r\n * An action creator attached to a slice.\r\n *\r\n * @deprecated please use PayloadActionCreator directly\r\n *\r\n * @public\r\n */\r\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\r\n\r\n/**\r\n * The return value of `createSlice`\r\n *\r\n * @public\r\n */\r\nexport interface Slice<\r\n  State = any,\r\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\r\n  Name extends string = string\r\n> {\r\n  /**\r\n   * The slice name.\r\n   */\r\n  name: Name\r\n\r\n  /**\r\n   * The slice's reducer.\r\n   */\r\n  reducer: Reducer<State>\r\n\r\n  /**\r\n   * Action creators for the types of actions that are handled by the slice\r\n   * reducer.\r\n   */\r\n  actions: CaseReducerActions<CaseReducers>\r\n\r\n  /**\r\n   * The individual case reducer functions that were passed in the `reducers` parameter.\r\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\r\n   */\r\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\r\n}\r\n\r\n/**\r\n * Options for `createSlice()`.\r\n *\r\n * @public\r\n */\r\nexport interface CreateSliceOptions<\r\n  State = any,\r\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\r\n  Name extends string = string\r\n> {\r\n  /**\r\n   * The slice's name. Used to namespace the generated action types.\r\n   */\r\n  name: Name\r\n\r\n  /**\r\n   * The initial state to be returned by the slice reducer.\r\n   */\r\n  initialState: State\r\n\r\n  /**\r\n   * A mapping from action types to action-type-specific *case reducer*\r\n   * functions. For every action type, a matching action creator will be\r\n   * generated using `createAction()`.\r\n   */\r\n  reducers: ValidateSliceCaseReducers<State, CR>\r\n\r\n  /**\r\n   * A mapping from action types to action-type-specific *case reducer*\r\n   * functions. These reducers should have existing action types used\r\n   * as the keys, and action creators will _not_ be generated.\r\n   * Alternatively, a callback that receives a *builder* object to define\r\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\r\n   */\r\n  extraReducers?:\r\n    | CaseReducers<NoInfer<State>, any>\r\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\r\n}\r\n\r\n/**\r\n * A CaseReducer with a `prepare` method.\r\n *\r\n * @public\r\n */\r\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\r\n  reducer: CaseReducer<State, Action>\r\n  prepare: PrepareAction<Action['payload']>\r\n}\r\n\r\n/**\r\n * The type describing a slice's `reducers` option.\r\n *\r\n * @public\r\n */\r\nexport type SliceCaseReducers<State> = {\r\n  [K: string]:\r\n    | CaseReducer<State, PayloadAction<any>>\r\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\r\n}\r\n\r\n/**\r\n * Derives the slice's `actions` property from the `reducers` options\r\n *\r\n * @public\r\n */\r\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\r\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\r\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\r\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\r\n}\r\n\r\n/**\r\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\r\n *\r\n * @internal\r\n */\r\ntype ActionCreatorForCaseReducerWithPrepare<\r\n  CR extends { prepare: any }\r\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\r\n\r\n/**\r\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\r\n *\r\n * @internal\r\n */\r\ntype ActionCreatorForCaseReducer<CR> = CR extends (\r\n  state: any,\r\n  action: infer Action\r\n) => any\r\n  ? Action extends { payload: infer P }\r\n    ? PayloadActionCreator<P>\r\n    : ActionCreatorWithoutPayload\r\n  : ActionCreatorWithoutPayload\r\n\r\n/**\r\n * Extracts the CaseReducers out of a `reducers` object, even if they are\r\n * tested into a `CaseReducerWithPrepare`.\r\n *\r\n * @internal\r\n */\r\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\r\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\r\n    reducer: infer Reducer\r\n  }\r\n    ? Reducer\r\n    : CaseReducers[Type]\r\n}\r\n\r\n/**\r\n * Helper type. Passes T out again, but boxes it in a way that it cannot\r\n * \"widen\" the type by accident if it is a generic that should be inferred\r\n * from elsewhere.\r\n *\r\n * @internal\r\n */\r\ntype NoInfer<T> = [T][T extends any ? 0 : never]\r\n\r\n/**\r\n * Used on a SliceCaseReducers object.\r\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\r\n * the `reducer` and the `prepare` function use the same type of `payload`.\r\n *\r\n * Might do additional such checks in the future.\r\n *\r\n * This type is only ever useful if you want to write your own wrapper around\r\n * `createSlice`. Please don't use it otherwise!\r\n *\r\n * @public\r\n */\r\nexport type ValidateSliceCaseReducers<\r\n  S,\r\n  ACR extends SliceCaseReducers<S>\r\n> = ACR &\r\n  {\r\n    [T in keyof ACR]: ACR[T] extends {\r\n      reducer(s: S, action?: infer A): any\r\n    }\r\n      ? {\r\n          prepare(...a: never[]): Omit<A, 'type'>\r\n        }\r\n      : {}\r\n  }\r\n\r\nfunction getType(slice: string, actionKey: string): string {\r\n  return `${slice}/${actionKey}`\r\n}\r\n\r\n/**\r\n * A function that accepts an initial state, an object full of reducer\r\n * functions, and a \"slice name\", and automatically generates\r\n * action creators and action types that correspond to the\r\n * reducers and state.\r\n *\r\n * The `reducer` argument is passed to `createReducer()`.\r\n *\r\n * @public\r\n */\r\nexport function createSlice<\r\n  State,\r\n  CaseReducers extends SliceCaseReducers<State>,\r\n  Name extends string = string\r\n>(\r\n  options: CreateSliceOptions<State, CaseReducers, Name>\r\n): Slice<State, CaseReducers, Name> {\r\n  const { name, initialState } = options\r\n  if (!name) {\r\n    throw new Error('`name` is a required option for createSlice')\r\n  }\r\n  const reducers = options.reducers || {}\r\n  const extraReducers =\r\n    typeof options.extraReducers === 'undefined'\r\n      ? {}\r\n      : typeof options.extraReducers === 'function'\r\n      ? executeReducerBuilderCallback(options.extraReducers)\r\n      : options.extraReducers\r\n\r\n  const reducerNames = Object.keys(reducers)\r\n\r\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\r\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\r\n  const actionCreators: Record<string, Function> = {}\r\n\r\n  reducerNames.forEach(reducerName => {\r\n    const maybeReducerWithPrepare = reducers[reducerName]\r\n    const type = getType(name, reducerName)\r\n\r\n    let caseReducer: CaseReducer<State, any>\r\n    let prepareCallback: PrepareAction<any> | undefined\r\n\r\n    if ('reducer' in maybeReducerWithPrepare) {\r\n      caseReducer = maybeReducerWithPrepare.reducer\r\n      prepareCallback = maybeReducerWithPrepare.prepare\r\n    } else {\r\n      caseReducer = maybeReducerWithPrepare\r\n    }\r\n\r\n    sliceCaseReducersByName[reducerName] = caseReducer\r\n    sliceCaseReducersByType[type] = caseReducer\r\n    actionCreators[reducerName] = prepareCallback\r\n      ? createAction(type, prepareCallback)\r\n      : createAction(type)\r\n  })\r\n\r\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\r\n  const reducer = createReducer(initialState, finalCaseReducers as any)\r\n\r\n  return {\r\n    name,\r\n    reducer,\r\n    actions: actionCreators as any,\r\n    caseReducers: sliceCaseReducersByName as any\r\n  }\r\n}\r\n","import { EntityState } from './models'\r\n\r\nexport function getInitialEntityState<V>(): EntityState<V> {\r\n  return {\r\n    ids: [],\r\n    entities: {}\r\n  }\r\n}\r\n\r\nexport function createInitialStateFactory<V>() {\r\n  function getInitialState(): EntityState<V>\r\n  function getInitialState<S extends object>(\r\n    additionalState: S\r\n  ): EntityState<V> & S\r\n  function getInitialState(additionalState: any = {}): any {\r\n    return Object.assign(getInitialEntityState(), additionalState)\r\n  }\r\n\r\n  return { getInitialState }\r\n}\r\n","import { createSelector } from 'reselect'\r\nimport { EntityState, EntitySelectors, Dictionary, EntityId } from './models'\r\n\r\nexport function createSelectorsFactory<T>() {\r\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\r\n  function getSelectors<V>(\r\n    selectState: (state: V) => EntityState<T>\r\n  ): EntitySelectors<T, V>\r\n  function getSelectors(\r\n    selectState?: (state: any) => EntityState<T>\r\n  ): EntitySelectors<T, any> {\r\n    const selectIds = (state: any) => state.ids\r\n\r\n    const selectEntities = (state: EntityState<T>) => state.entities\r\n\r\n    const selectAll = createSelector(\r\n      selectIds,\r\n      selectEntities,\r\n      (ids: T[], entities: Dictionary<T>): any =>\r\n        ids.map((id: any) => (entities as any)[id])\r\n    )\r\n\r\n    const selectId = (_: any, id: EntityId) => id\r\n\r\n    const selectById = (entities: Dictionary<T>, id: EntityId) => entities[id]\r\n\r\n    const selectTotal = createSelector(selectIds, ids => ids.length)\r\n\r\n    if (!selectState) {\r\n      return {\r\n        selectIds,\r\n        selectEntities,\r\n        selectAll,\r\n        selectTotal,\r\n        selectById: createSelector(selectEntities, selectId, selectById)\r\n      }\r\n    }\r\n\r\n    const selectGlobalizedEntities = createSelector(selectState, selectEntities)\r\n\r\n    return {\r\n      selectIds: createSelector(selectState, selectIds),\r\n      selectEntities: selectGlobalizedEntities,\r\n      selectAll: createSelector(selectState, selectAll),\r\n      selectTotal: createSelector(selectState, selectTotal),\r\n      selectById: createSelector(selectGlobalizedEntities, selectId, selectById)\r\n    }\r\n  }\r\n\r\n  return { getSelectors }\r\n}\r\n","import createNextState, { isDraft } from 'immer'\r\nimport { EntityState } from './models'\r\nimport { PayloadAction, isFSA } from '../createAction'\r\n\r\nexport function createStateOperator<V, R>(\r\n  mutator: (arg: R, state: EntityState<V>) => void\r\n) {\r\n  return function operation<S extends EntityState<V>>(\r\n    state: S,\r\n    arg: R | PayloadAction<R>\r\n  ): S {\r\n    function isPayloadActionArgument(\r\n      arg: R | PayloadAction<R>\r\n    ): arg is PayloadAction<R> {\r\n      return isFSA(arg)\r\n    }\r\n\r\n    const runMutator = (draft: EntityState<V>) => {\r\n      if (isPayloadActionArgument(arg)) {\r\n        mutator(arg.payload, draft)\r\n      } else {\r\n        mutator(arg, draft)\r\n      }\r\n    }\r\n\r\n    if (isDraft(state)) {\r\n      // we must already be inside a `createNextState` call, likely because\r\n      // this is being wrapped in `createReducer` or `createSlice`.\r\n      // It's safe to just pass the draft to the mutator.\r\n      runMutator(state)\r\n\r\n      // since it's a draft, we'll just return it\r\n      return state\r\n    } else {\r\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\r\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\r\n      // these two types.\r\n      return createNextState(state, runMutator)\r\n    }\r\n  }\r\n}\r\n","import { IdSelector } from './models'\r\n\r\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\r\n  const key = selectId(entity)\r\n\r\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\r\n    console.warn(\r\n      'The entity passed to the `selectId` implementation returned undefined.',\r\n      'You should probably provide your own `selectId` implementation.',\r\n      'The entity that was passed:',\r\n      entity,\r\n      'The `selectId` implementation:',\r\n      selectId.toString()\r\n    )\r\n  }\r\n\r\n  return key\r\n}\r\n","import {\r\n  EntityState,\r\n  EntityStateAdapter,\r\n  IdSelector,\r\n  Update,\r\n  EntityId\r\n} from './models'\r\nimport { createStateOperator } from './state_adapter'\r\nimport { selectIdValue } from './utils'\r\n\r\nexport function createUnsortedStateAdapter<T>(\r\n  selectId: IdSelector<T>\r\n): EntityStateAdapter<T> {\r\n  type R = EntityState<T>\r\n\r\n  function addOneMutably(entity: T, state: EntityState<T>): void {\r\n    const key = selectIdValue(entity, selectId)\r\n\r\n    if (key in state.entities) {\r\n      return\r\n    }\r\n\r\n    state.ids.push(key)\r\n    state.entities[key] = entity\r\n  }\r\n\r\n  function addManyMutably(entities: T[] | Record<EntityId, T>, state: R): void {\r\n    if (!Array.isArray(entities)) {\r\n      entities = Object.values(entities)\r\n    }\r\n\r\n    for (const entity of entities) {\r\n      addOneMutably(entity, state)\r\n    }\r\n  }\r\n\r\n  function setAllMutably(entities: T[] | Record<EntityId, T>, state: R): void {\r\n    if (!Array.isArray(entities)) {\r\n      entities = Object.values(entities)\r\n    }\r\n\r\n    state.ids = []\r\n    state.entities = {}\r\n\r\n    addManyMutably(entities, state)\r\n  }\r\n\r\n  function removeOneMutably(key: EntityId, state: R): void {\r\n    return removeManyMutably([key], state)\r\n  }\r\n\r\n  function removeManyMutably(keys: EntityId[], state: R): void {\r\n    let didMutate = false\r\n\r\n    keys.forEach(key => {\r\n      if (key in state.entities) {\r\n        delete state.entities[key]\r\n        didMutate = true\r\n      }\r\n    })\r\n\r\n    if (didMutate) {\r\n      state.ids = state.ids.filter(id => id in state.entities)\r\n    }\r\n  }\r\n\r\n  function removeAll(state: R): any {\r\n    return Object.assign({}, state, {\r\n      ids: [],\r\n      entities: {}\r\n    })\r\n  }\r\n\r\n  function takeNewKey(\r\n    keys: { [id: string]: EntityId },\r\n    update: Update<T>,\r\n    state: R\r\n  ): boolean {\r\n    const original = state.entities[update.id]\r\n    const updated: T = Object.assign({}, original, update.changes)\r\n    const newKey = selectIdValue(updated, selectId)\r\n    const hasNewKey = newKey !== update.id\r\n\r\n    if (hasNewKey) {\r\n      keys[update.id] = newKey\r\n      delete state.entities[update.id]\r\n    }\r\n\r\n    state.entities[newKey] = updated\r\n\r\n    return hasNewKey\r\n  }\r\n\r\n  function updateOneMutably(update: Update<T>, state: R): void {\r\n    return updateManyMutably([update], state)\r\n  }\r\n\r\n  function updateManyMutably(updates: Update<T>[], state: R): void {\r\n    const newKeys: { [id: string]: EntityId } = {}\r\n\r\n    const updatesPerEntity: { [id: string]: Update<T> } = {}\r\n\r\n    updates.forEach(update => {\r\n      // Only apply updates to entities that currently exist\r\n      if (update.id in state.entities) {\r\n        // If there are multiple updates to one entity, merge them together\r\n        updatesPerEntity[update.id] = {\r\n          // Spreads ignore falsy values, so this works even if there isn't\r\n          // an existing update already at this key\r\n          ...updatesPerEntity[update.id],\r\n          ...update\r\n        }\r\n      }\r\n    })\r\n\r\n    updates = Object.values(updatesPerEntity)\r\n\r\n    const didMutateEntities = updates.length > 0\r\n\r\n    if (didMutateEntities) {\r\n      const didMutateIds =\r\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\r\n\r\n      if (didMutateIds) {\r\n        state.ids = state.ids.map(id => newKeys[id] || id)\r\n      }\r\n    }\r\n  }\r\n\r\n  function upsertOneMutably(entity: T, state: R): void {\r\n    return upsertManyMutably([entity], state)\r\n  }\r\n\r\n  function upsertManyMutably(\r\n    entities: T[] | Record<EntityId, T>,\r\n    state: R\r\n  ): void {\r\n    if (!Array.isArray(entities)) {\r\n      entities = Object.values(entities)\r\n    }\r\n\r\n    const added: T[] = []\r\n    const updated: Update<T>[] = []\r\n\r\n    for (const entity of entities) {\r\n      const id = selectIdValue(entity, selectId)\r\n      if (id in state.entities) {\r\n        updated.push({ id, changes: entity })\r\n      } else {\r\n        added.push(entity)\r\n      }\r\n    }\r\n\r\n    updateManyMutably(updated, state)\r\n    addManyMutably(added, state)\r\n  }\r\n\r\n  return {\r\n    removeAll,\r\n    addOne: createStateOperator(addOneMutably),\r\n    addMany: createStateOperator(addManyMutably),\r\n    setAll: createStateOperator(setAllMutably),\r\n    updateOne: createStateOperator(updateOneMutably),\r\n    updateMany: createStateOperator(updateManyMutably),\r\n    upsertOne: createStateOperator(upsertOneMutably),\r\n    upsertMany: createStateOperator(upsertManyMutably),\r\n    removeOne: createStateOperator(removeOneMutably),\r\n    removeMany: createStateOperator(removeManyMutably)\r\n  }\r\n}\r\n","import {\r\n  EntityState,\r\n  IdSelector,\r\n  Comparer,\r\n  EntityStateAdapter,\r\n  Update,\r\n  EntityId\r\n} from './models'\r\nimport { createStateOperator } from './state_adapter'\r\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\r\nimport { selectIdValue } from './utils'\r\n\r\nexport function createSortedStateAdapter<T>(\r\n  selectId: IdSelector<T>,\r\n  sort: Comparer<T>\r\n): EntityStateAdapter<T> {\r\n  type R = EntityState<T>\r\n\r\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\r\n    selectId\r\n  )\r\n\r\n  function addOneMutably(entity: T, state: R): void {\r\n    return addManyMutably([entity], state)\r\n  }\r\n\r\n  function addManyMutably(\r\n    newModels: T[] | Record<EntityId, T>,\r\n    state: R\r\n  ): void {\r\n    if (!Array.isArray(newModels)) {\r\n      newModels = Object.values(newModels)\r\n    }\r\n\r\n    const models = newModels.filter(\r\n      model => !(selectIdValue(model, selectId) in state.entities)\r\n    )\r\n\r\n    if (models.length !== 0) {\r\n      merge(models, state)\r\n    }\r\n  }\r\n\r\n  function setAllMutably(models: T[] | Record<EntityId, T>, state: R): void {\r\n    if (!Array.isArray(models)) {\r\n      models = Object.values(models)\r\n    }\r\n    state.entities = {}\r\n    state.ids = []\r\n\r\n    addManyMutably(models, state)\r\n  }\r\n\r\n  function updateOneMutably(update: Update<T>, state: R): void {\r\n    return updateManyMutably([update], state)\r\n  }\r\n\r\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean {\r\n    if (!(update.id in state.entities)) {\r\n      return false\r\n    }\r\n\r\n    const original = state.entities[update.id]\r\n    const updated = Object.assign({}, original, update.changes)\r\n    const newKey = selectIdValue(updated, selectId)\r\n\r\n    delete state.entities[update.id]\r\n\r\n    models.push(updated)\r\n\r\n    return newKey !== update.id\r\n  }\r\n\r\n  function updateManyMutably(updates: Update<T>[], state: R): void {\r\n    const models: T[] = []\r\n\r\n    updates.forEach(update => takeUpdatedModel(models, update, state))\r\n\r\n    if (models.length !== 0) {\r\n      merge(models, state)\r\n    }\r\n  }\r\n\r\n  function upsertOneMutably(entity: T, state: R): void {\r\n    return upsertManyMutably([entity], state)\r\n  }\r\n\r\n  function upsertManyMutably(\r\n    entities: T[] | Record<EntityId, T>,\r\n    state: R\r\n  ): void {\r\n    if (!Array.isArray(entities)) {\r\n      entities = Object.values(entities)\r\n    }\r\n\r\n    const added: T[] = []\r\n    const updated: Update<T>[] = []\r\n\r\n    for (const entity of entities) {\r\n      const id = selectIdValue(entity, selectId)\r\n      if (id in state.entities) {\r\n        updated.push({ id, changes: entity })\r\n      } else {\r\n        added.push(entity)\r\n      }\r\n    }\r\n\r\n    updateManyMutably(updated, state)\r\n    addManyMutably(added, state)\r\n  }\r\n\r\n  function areArraysEqual(a: unknown[], b: unknown[]) {\r\n    if (a.length !== b.length) {\r\n      return false\r\n    }\r\n\r\n    for (let i = 0; i < a.length && i < b.length; i++) {\r\n      if (a[i] === b[i]) {\r\n        continue\r\n      }\r\n      return false\r\n    }\r\n    return true\r\n  }\r\n\r\n  function merge(models: T[], state: R): void {\r\n    models.sort(sort)\r\n\r\n    // Insert/overwrite all new/updated\r\n    models.forEach(model => {\r\n      state.entities[selectId(model)] = model\r\n    })\r\n\r\n    const allEntities = Object.values(state.entities) as T[]\r\n    allEntities.sort(sort)\r\n\r\n    const newSortedIds = allEntities.map(selectId)\r\n    const { ids } = state\r\n\r\n    if (!areArraysEqual(ids, newSortedIds)) {\r\n      state.ids = newSortedIds\r\n    }\r\n  }\r\n\r\n  return {\r\n    removeOne,\r\n    removeMany,\r\n    removeAll,\r\n    addOne: createStateOperator(addOneMutably),\r\n    updateOne: createStateOperator(updateOneMutably),\r\n    upsertOne: createStateOperator(upsertOneMutably),\r\n    setAll: createStateOperator(setAllMutably),\r\n    addMany: createStateOperator(addManyMutably),\r\n    updateMany: createStateOperator(updateManyMutably),\r\n    upsertMany: createStateOperator(upsertManyMutably)\r\n  }\r\n}\r\n","import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\r\nimport { createInitialStateFactory } from './entity_state'\r\nimport { createSelectorsFactory } from './state_selectors'\r\nimport { createSortedStateAdapter } from './sorted_state_adapter'\r\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\r\n\r\n/**\r\n *\r\n * @param options\r\n *\r\n * @public\r\n */\r\nexport function createEntityAdapter<T>(\r\n  options: {\r\n    selectId?: IdSelector<T>\r\n    sortComparer?: false | Comparer<T>\r\n  } = {}\r\n): EntityAdapter<T> {\r\n  const { selectId, sortComparer }: EntityDefinition<T> = {\r\n    sortComparer: false,\r\n    selectId: (instance: any) => instance.id,\r\n    ...options\r\n  }\r\n\r\n  const stateFactory = createInitialStateFactory<T>()\r\n  const selectorsFactory = createSelectorsFactory<T>()\r\n  const stateAdapter = sortComparer\r\n    ? createSortedStateAdapter(selectId, sortComparer)\r\n    : createUnsortedStateAdapter(selectId)\r\n\r\n  return {\r\n    selectId,\r\n    sortComparer,\r\n    ...stateFactory,\r\n    ...selectorsFactory,\r\n    ...stateAdapter\r\n  }\r\n}\r\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","// Borrowed from https://github.com/ai/nanoid/blob/3.0.2/non-secure/index.js\r\n// This alphabet uses `A-Za-z0-9_-` symbols. A genetic algorithm helped\r\n// optimize the gzip compression for this alphabet.\r\nlet urlAlphabet =\r\n  'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW'\r\n\r\n/**\r\n *\r\n * @public\r\n */\r\nexport let nanoid = (size = 21) => {\r\n  let id = ''\r\n  // A compact alternative for `for (var i = 0; i < step; i++)`.\r\n  let i = size\r\n  while (i--) {\r\n    // `| 0` is more compact and faster than `Math.floor()`.\r\n    id += urlAlphabet[(Math.random() * 64) | 0]\r\n  }\r\n  return id\r\n}\r\n","import { Dispatch, AnyAction } from 'redux'\r\nimport {\r\n  createAction,\r\n  PayloadAction,\r\n  ActionCreatorWithPreparedPayload\r\n} from './createAction'\r\nimport { ThunkDispatch } from 'redux-thunk'\r\nimport { FallbackIfUnknown, IsAny } from './tsHelpers'\r\nimport { nanoid } from './nanoid'\r\n\r\n// @ts-ignore we need the import of these types due to a bundling issue.\r\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\r\n\r\nexport type BaseThunkAPI<\r\n  S,\r\n  E,\r\n  D extends Dispatch = Dispatch,\r\n  RejectedValue = undefined\r\n> = {\r\n  dispatch: D\r\n  getState: () => S\r\n  extra: E\r\n  requestId: string\r\n  signal: AbortSignal\r\n  rejectWithValue(value: RejectedValue): RejectWithValue<RejectedValue>\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface SerializedError {\r\n  name?: string\r\n  message?: string\r\n  stack?: string\r\n  code?: string\r\n}\r\n\r\nconst commonProperties: Array<keyof SerializedError> = [\r\n  'name',\r\n  'message',\r\n  'stack',\r\n  'code'\r\n]\r\n\r\nclass RejectWithValue<RejectValue> {\r\n  constructor(public readonly value: RejectValue) {}\r\n}\r\n\r\n// Reworked from https://github.com/sindresorhus/serialize-error\r\nexport const miniSerializeError = (value: any): SerializedError => {\r\n  if (typeof value === 'object' && value !== null) {\r\n    const simpleError: SerializedError = {}\r\n    for (const property of commonProperties) {\r\n      if (typeof value[property] === 'string') {\r\n        simpleError[property] = value[property]\r\n      }\r\n    }\r\n\r\n    return simpleError\r\n  }\r\n\r\n  return { message: String(value) }\r\n}\r\n\r\ntype AsyncThunkConfig = {\r\n  state?: unknown\r\n  dispatch?: Dispatch\r\n  extra?: unknown\r\n  rejectValue?: unknown\r\n}\r\n\r\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\r\n  state: infer State\r\n}\r\n  ? State\r\n  : unknown\r\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\r\n  ? Extra\r\n  : unknown\r\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\r\n  dispatch: infer Dispatch\r\n}\r\n  ? FallbackIfUnknown<\r\n      Dispatch,\r\n      ThunkDispatch<\r\n        GetState<ThunkApiConfig>,\r\n        GetExtra<ThunkApiConfig>,\r\n        AnyAction\r\n      >\r\n    >\r\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\r\n\r\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\r\n  GetState<ThunkApiConfig>,\r\n  GetExtra<ThunkApiConfig>,\r\n  GetDispatch<ThunkApiConfig>,\r\n  GetRejectValue<ThunkApiConfig>\r\n>\r\n\r\ntype GetRejectValue<ThunkApiConfig> = ThunkApiConfig extends {\r\n  rejectValue: infer RejectValue\r\n}\r\n  ? RejectValue\r\n  : unknown\r\n/**\r\n * A type describing the return value of the `payloadCreator` argument to `createAsyncThunk`.\r\n * Might be useful for wrapping `createAsyncThunk` in custom abstractions.\r\n *\r\n * @public\r\n */\r\nexport type AsyncThunkPayloadCreatorReturnValue<\r\n  Returned,\r\n  ThunkApiConfig extends AsyncThunkConfig\r\n> =\r\n  | Promise<Returned | RejectWithValue<GetRejectValue<ThunkApiConfig>>>\r\n  | Returned\r\n  | RejectWithValue<GetRejectValue<ThunkApiConfig>>\r\n/**\r\n * A type describing the `payloadCreator` argument to `createAsyncThunk`.\r\n * Might be useful for wrapping `createAsyncThunk` in custom abstractions.\r\n *\r\n * @public\r\n */\r\nexport type AsyncThunkPayloadCreator<\r\n  Returned,\r\n  ThunkArg = void,\r\n  ThunkApiConfig extends AsyncThunkConfig = {}\r\n> = (\r\n  arg: ThunkArg,\r\n  thunkAPI: GetThunkAPI<ThunkApiConfig>\r\n) => AsyncThunkPayloadCreatorReturnValue<Returned, ThunkApiConfig>\r\n\r\n/**\r\n * A ThunkAction created by `createAsyncThunk`.\r\n * Dispatching it returns a Promise for either a\r\n * fulfilled or rejected action.\r\n * Also, the returned value contains a `abort()` method\r\n * that allows the asyncAction to be cancelled from the outside.\r\n *\r\n * @public\r\n */\r\nexport type AsyncThunkAction<\r\n  Returned,\r\n  ThunkArg,\r\n  ThunkApiConfig extends AsyncThunkConfig\r\n> = (\r\n  dispatch: GetDispatch<ThunkApiConfig>,\r\n  getState: () => GetState<ThunkApiConfig>,\r\n  extra: GetExtra<ThunkApiConfig>\r\n) => Promise<\r\n  | PayloadAction<Returned, string, { arg: ThunkArg; requestId: string }>\r\n  | PayloadAction<\r\n      undefined | GetRejectValue<ThunkApiConfig>,\r\n      string,\r\n      {\r\n        arg: ThunkArg\r\n        requestId: string\r\n        aborted: boolean\r\n        condition: boolean\r\n      },\r\n      SerializedError\r\n    >\r\n> & {\r\n  abort(reason?: string): void\r\n}\r\n\r\ntype AsyncThunkActionCreator<\r\n  Returned,\r\n  ThunkArg,\r\n  ThunkApiConfig extends AsyncThunkConfig\r\n> = IsAny<\r\n  ThunkArg,\r\n  // any handling\r\n  (arg: ThunkArg) => AsyncThunkAction<Returned, ThunkArg, ThunkApiConfig>,\r\n  // unknown handling\r\n  unknown extends ThunkArg\r\n    ? (arg: ThunkArg) => AsyncThunkAction<Returned, ThunkArg, ThunkApiConfig> // argument not specified or specified as void or undefined\r\n    : [ThunkArg] extends [void] | [undefined]\r\n    ? () => AsyncThunkAction<Returned, ThunkArg, ThunkApiConfig> // argument contains void\r\n    : [void] extends [ThunkArg] // make optional\r\n    ? (arg?: ThunkArg) => AsyncThunkAction<Returned, ThunkArg, ThunkApiConfig> // argument contains undefined\r\n    : [undefined] extends [ThunkArg]\r\n    ? WithStrictNullChecks<\r\n        // with strict nullChecks: make optional\r\n        (\r\n          arg?: ThunkArg\r\n        ) => AsyncThunkAction<Returned, ThunkArg, ThunkApiConfig>,\r\n        // without strict null checks this will match everything, so don't make it optional\r\n        (arg: ThunkArg) => AsyncThunkAction<Returned, ThunkArg, ThunkApiConfig>\r\n      > // default case: normal argument\r\n    : (arg: ThunkArg) => AsyncThunkAction<Returned, ThunkArg, ThunkApiConfig>\r\n>\r\n\r\ninterface AsyncThunkOptions<\r\n  ThunkArg = void,\r\n  ThunkApiConfig extends AsyncThunkConfig = {}\r\n> {\r\n  /**\r\n   * A method to control whether the asyncThunk should be executed. Has access to the\r\n   * `arg`, `api.getState()` and `api.extra` arguments.\r\n   *\r\n   * @returns `true` if the asyncThunk should be executed, `false` if it should be skipped\r\n   */\r\n  condition?(\r\n    arg: ThunkArg,\r\n    api: Pick<GetThunkAPI<ThunkApiConfig>, 'getState' | 'extra'>\r\n  ): boolean\r\n  /**\r\n   * If `condition` returns `false`, the asyncThunk will be skipped.\r\n   * This option allows you to control whether a `rejected` action with `meta.condition == false`\r\n   * will be dispatched or not.\r\n   *\r\n   * @default `false`\r\n   */\r\n  dispatchConditionRejection?: boolean\r\n}\r\n\r\n/**\r\n *\r\n * @param type\r\n * @param payloadCreator\r\n * @param options\r\n *\r\n * @public\r\n */\r\nexport function createAsyncThunk<\r\n  Returned,\r\n  ThunkArg = void,\r\n  ThunkApiConfig extends AsyncThunkConfig = {}\r\n>(\r\n  type: string,\r\n  payloadCreator: (\r\n    arg: ThunkArg,\r\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\r\n  ) =>\r\n    | Promise<Returned | RejectWithValue<GetRejectValue<ThunkApiConfig>>>\r\n    | Returned\r\n    | RejectWithValue<GetRejectValue<ThunkApiConfig>>,\r\n  options?: AsyncThunkOptions<ThunkArg, ThunkApiConfig>\r\n) {\r\n  type RejectedValue = GetRejectValue<ThunkApiConfig>\r\n\r\n  const fulfilled = createAction(\r\n    type + '/fulfilled',\r\n    (result: Returned, requestId: string, arg: ThunkArg) => {\r\n      return {\r\n        payload: result,\r\n        meta: { arg, requestId }\r\n      }\r\n    }\r\n  )\r\n\r\n  const pending = createAction(\r\n    type + '/pending',\r\n    (requestId: string, arg: ThunkArg) => {\r\n      return {\r\n        payload: undefined,\r\n        meta: { arg, requestId }\r\n      }\r\n    }\r\n  )\r\n\r\n  const rejected = createAction(\r\n    type + '/rejected',\r\n    (\r\n      error: Error | null,\r\n      requestId: string,\r\n      arg: ThunkArg,\r\n      payload?: RejectedValue\r\n    ) => {\r\n      const aborted = !!error && error.name === 'AbortError'\r\n      const condition = !!error && error.name === 'ConditionError'\r\n      return {\r\n        payload,\r\n        error: miniSerializeError(error || 'Rejected'),\r\n        meta: {\r\n          arg,\r\n          requestId,\r\n          aborted,\r\n          condition\r\n        }\r\n      }\r\n    }\r\n  )\r\n\r\n  let displayedWarning = false\r\n\r\n  const AC =\r\n    typeof AbortController !== 'undefined'\r\n      ? AbortController\r\n      : class implements AbortController {\r\n          signal: AbortSignal = {\r\n            aborted: false,\r\n            addEventListener() {},\r\n            dispatchEvent() {\r\n              return false\r\n            },\r\n            onabort() {},\r\n            removeEventListener() {}\r\n          }\r\n          abort() {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n              if (!displayedWarning) {\r\n                displayedWarning = true\r\n                console.info(\r\n                  `This platform does not implement AbortController. \r\nIf you want to use the AbortController to react to \\`abort\\` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.`\r\n                )\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n  function actionCreator(\r\n    arg: ThunkArg\r\n  ): AsyncThunkAction<Returned, ThunkArg, ThunkApiConfig> {\r\n    return (dispatch, getState, extra) => {\r\n      const requestId = nanoid()\r\n\r\n      const abortController = new AC()\r\n      let abortReason: string | undefined\r\n\r\n      const abortedPromise = new Promise<never>((_, reject) =>\r\n        abortController.signal.addEventListener('abort', () =>\r\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\r\n        )\r\n      )\r\n\r\n      function abort(reason?: string) {\r\n        abortReason = reason\r\n        abortController.abort()\r\n      }\r\n\r\n      const promise = (async function() {\r\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\r\n        try {\r\n          if (\r\n            options &&\r\n            options.condition &&\r\n            options.condition(arg, { getState, extra }) === false\r\n          ) {\r\n            throw {\r\n              name: 'ConditionError',\r\n              message: 'Aborted due to condition callback returning false.'\r\n            }\r\n          }\r\n          dispatch(pending(requestId, arg))\r\n          finalAction = await Promise.race([\r\n            abortedPromise,\r\n            Promise.resolve(\r\n              payloadCreator(arg, {\r\n                dispatch,\r\n                getState,\r\n                extra,\r\n                requestId,\r\n                signal: abortController.signal,\r\n                rejectWithValue(value: RejectedValue) {\r\n                  return new RejectWithValue(value)\r\n                }\r\n              })\r\n            ).then(result => {\r\n              if (result instanceof RejectWithValue) {\r\n                return rejected(null, requestId, arg, result.value)\r\n              }\r\n              return fulfilled(result, requestId, arg)\r\n            })\r\n          ])\r\n        } catch (err) {\r\n          finalAction = rejected(err, requestId, arg)\r\n        }\r\n        // We dispatch the result action _after_ the catch, to avoid having any errors\r\n        // here get swallowed by the try/catch block,\r\n        // per https://twitter.com/dan_abramov/status/770914221638942720\r\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\r\n\r\n        const skipDispatch =\r\n          options &&\r\n          !options.dispatchConditionRejection &&\r\n          rejected.match(finalAction) &&\r\n          finalAction.meta.condition\r\n\r\n        if (!skipDispatch) {\r\n          dispatch(finalAction)\r\n        }\r\n        return finalAction\r\n      })()\r\n      return Object.assign(promise, { abort })\r\n    }\r\n  }\r\n\r\n  return Object.assign(\r\n    actionCreator as AsyncThunkActionCreator<\r\n      Returned,\r\n      ThunkArg,\r\n      ThunkApiConfig\r\n    >,\r\n    {\r\n      pending,\r\n      rejected,\r\n      fulfilled\r\n    }\r\n  )\r\n}\r\n\r\ntype ActionTypesWithOptionalErrorAction =\r\n  | { error: any }\r\n  | { error?: never; payload: any }\r\ntype PayloadForActionTypesExcludingErrorActions<T> = T extends { error: any }\r\n  ? never\r\n  : T extends { payload: infer P }\r\n  ? P\r\n  : never\r\n\r\n/**\r\n * @public\r\n */\r\nexport function unwrapResult<R extends ActionTypesWithOptionalErrorAction>(\r\n  returned: R\r\n): PayloadForActionTypesExcludingErrorActions<R> {\r\n  if ('error' in returned) {\r\n    throw returned.error\r\n  }\r\n  return (returned as any).payload\r\n}\r\n\r\ntype WithStrictNullChecks<True, False> = undefined extends boolean\r\n  ? False\r\n  : True\r\n","import { enableES5 } from 'immer'\r\nexport * from 'redux'\r\nexport { default as createNextState, Draft } from 'immer'\r\nexport {\r\n  createSelector,\r\n  Selector,\r\n  OutputParametricSelector,\r\n  OutputSelector,\r\n  ParametricSelector\r\n} from 'reselect'\r\nexport { ThunkAction, ThunkDispatch } from 'redux-thunk'\r\n\r\n// We deliberately enable Immer's ES5 support, on the grounds that\r\n// we assume RTK will be used with React Native and other Proxy-less\r\n// environments.  In addition, that's how Immer 4 behaved, and since\r\n// we want to ship this in an RTK minor, we should keep the same behavior.\r\nenableES5()\r\n\r\nexport {\r\n  // js\r\n  configureStore,\r\n  // types\r\n  ConfigureEnhancersCallback,\r\n  ConfigureStoreOptions,\r\n  EnhancedStore\r\n} from './configureStore'\r\nexport {\r\n  // js\r\n  createAction,\r\n  getType,\r\n  // types\r\n  PayloadAction,\r\n  PayloadActionCreator,\r\n  ActionCreatorWithNonInferrablePayload,\r\n  ActionCreatorWithOptionalPayload,\r\n  ActionCreatorWithPayload,\r\n  ActionCreatorWithoutPayload,\r\n  ActionCreatorWithPreparedPayload,\r\n  PrepareAction\r\n} from './createAction'\r\nexport {\r\n  // js\r\n  createReducer,\r\n  // types\r\n  Actions,\r\n  CaseReducer,\r\n  CaseReducers\r\n} from './createReducer'\r\nexport {\r\n  // js\r\n  createSlice,\r\n  // types\r\n  CreateSliceOptions,\r\n  Slice,\r\n  CaseReducerActions,\r\n  SliceCaseReducers,\r\n  ValidateSliceCaseReducers,\r\n  CaseReducerWithPrepare,\r\n  SliceActionCreator\r\n} from './createSlice'\r\nexport {\r\n  // js\r\n  createImmutableStateInvariantMiddleware,\r\n  isImmutableDefault,\r\n  // types\r\n  ImmutableStateInvariantMiddlewareOptions\r\n} from './immutableStateInvariantMiddleware'\r\nexport {\r\n  // js\r\n  createSerializableStateInvariantMiddleware,\r\n  findNonSerializableValue,\r\n  isPlain,\r\n  // types\r\n  SerializableStateInvariantMiddlewareOptions\r\n} from './serializableStateInvariantMiddleware'\r\nexport {\r\n  // js\r\n  getDefaultMiddleware\r\n} from './getDefaultMiddleware'\r\nexport {\r\n  // types\r\n  ActionReducerMapBuilder\r\n} from './mapBuilders'\r\n\r\nexport { createEntityAdapter } from './entities/create_adapter'\r\nexport {\r\n  Dictionary,\r\n  EntityState,\r\n  EntityAdapter,\r\n  EntitySelectors,\r\n  EntityStateAdapter,\r\n  EntityId,\r\n  Update,\r\n  IdSelector,\r\n  Comparer\r\n} from './entities/models'\r\n\r\nexport {\r\n  AsyncThunkAction,\r\n  AsyncThunkPayloadCreatorReturnValue,\r\n  AsyncThunkPayloadCreator,\r\n  createAsyncThunk,\r\n  unwrapResult,\r\n  SerializedError\r\n} from './createAsyncThunk'\r\n\r\nexport { nanoid } from './nanoid'\r\n"],"names":["composeWithDevTools","window","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","arguments","length","undefined","compose","apply","isPlainObject","value","proto","Object","getPrototypeOf","getTimeMeasureUtils","maxDelay","fnName","elapsed","measureTime","fn","started","Date","now","finished","warnIfExceeded","console","warn","prefix","invariant","condition","message","Error","stringify","obj","serializer","indent","decycler","JSON","getSerialize","stack","keys","_","slice","indexOf","join","key","thisPos","splice","push","Infinity","call","isImmutableDefault","trackForMutations","isImmutable","ignorePaths","trackedProperties","trackProperties","detectMutations","path","tracked","children","childPath","concat","trackedProperty","sameParentRef","prevObj","sameRef","Number","isNaN","wasMutated","keysToDetect","forEach","i","result","createImmutableStateInvariantMiddleware","options","ignoredPaths","warnAfter","ignore","track","bind","getState","state","tracker","next","action","measureUtils","dispatchedAction","isPlain","val","Array","isArray","findNonSerializableValue","isSerializable","getEntries","foundNestedSerializable","keyPath","entries","hasIgnoredPaths","property","nestedValue","nestedPath","createSerializableStateInvariantMiddleware","ignoredActions","ignoredActionPaths","storeAPI","type","foundActionNonSerializableValue","error","foundStateNonSerializableValue","isBoolean","x","getDefaultMiddleware","thunk","immutableCheck","serializableCheck","middlewareArray","thunkMiddleware","withExtraArgument","extraArgument","immutableOptions","unshift","serializableOptions","IS_PRODUCTION","process","configureStore","reducer","middleware","devTools","preloadedState","enhancers","rootReducer","combineReducers","middlewareEnhancer","applyMiddleware","finalCompose","trace","storeEnhancers","composedEnhancer","createStore","createAction","prepareAction","actionCreator","prepared","payload","meta","toString","match","isFSA","every","isValidKey","getType","executeReducerBuilderCallback","builderCallback","actionsMap","builder","addCase","typeOrActionCreator","createReducer","initialState","mapOrBuilderCallback","createNextState","draft","caseReducer","actionKey","createSlice","name","reducers","extraReducers","reducerNames","sliceCaseReducersByName","sliceCaseReducersByType","actionCreators","reducerName","maybeReducerWithPrepare","prepareCallback","prepare","finalCaseReducers","actions","caseReducers","getInitialEntityState","ids","entities","createInitialStateFactory","getInitialState","additionalState","assign","createSelectorsFactory","getSelectors","selectState","selectIds","selectEntities","selectAll","createSelector","map","id","selectId","selectById","selectTotal","selectGlobalizedEntities","createStateOperator","mutator","operation","arg","isPayloadActionArgument","runMutator","isDraft","selectIdValue","entity","createUnsortedStateAdapter","addOneMutably","addManyMutably","values","setAllMutably","removeOneMutably","removeManyMutably","didMutate","filter","removeAll","takeNewKey","update","original","updated","changes","newKey","hasNewKey","updateOneMutably","updateManyMutably","updates","newKeys","updatesPerEntity","didMutateEntities","didMutateIds","upsertOneMutably","upsertManyMutably","added","addOne","addMany","setAll","updateOne","updateMany","upsertOne","upsertMany","removeOne","removeMany","createSortedStateAdapter","sort","newModels","models","model","merge","takeUpdatedModel","areArraysEqual","a","b","allEntities","newSortedIds","createEntityAdapter","sortComparer","instance","stateFactory","selectorsFactory","stateAdapter","urlAlphabet","nanoid","size","Math","random","commonProperties","RejectWithValue","miniSerializeError","simpleError","String","createAsyncThunk","payloadCreator","fulfilled","requestId","pending","rejected","aborted","displayedWarning","AC","AbortController","addEventListener","dispatchEvent","onabort","removeEventListener","abort","info","dispatch","extra","abortController","abortReason","abortedPromise","Promise","reject","signal","reason","promise","skipDispatch","dispatchConditionRejection","finalAction","race","resolve","rejectWithValue","then","err","unwrapResult","returned","enableES5"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4KA;;;;AAGA,AAAO,IAAMA,mBAAmB,GAI9B,OAAOC,MAAP,KAAkB,WAAlB,IACCA,MAAc,CAACC,oCADhB,GAEKD,MAAc,CAACC,oCAFpB,GAGI;MACMC,SAAS,CAACC,MAAV,KAAqB,CAAzB,EAA4B,OAAOC,SAAP;MACxB,OAAOF,SAAS,CAAC,CAAD,CAAhB,KAAwB,QAA5B,EAAsC,OAAOG,aAAP;SAC/BA,aAAO,CAACC,KAAR,CAAc,IAAd,EAAqBJ,SAArB,CAAP;CAVD;;AC/KP;;;;;;;;AAQA,SAAwBK,cAAcC;MAChC,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD,OAAO,KAAP;MAE7CC,KAAK,GAAGD,KAAZ;;SACOE,MAAM,CAACC,cAAP,CAAsBF,KAAtB,MAAiC,IAAxC,EAA8C;IAC5CA,KAAK,GAAGC,MAAM,CAACC,cAAP,CAAsBF,KAAtB,CAAR;;;SAGKC,MAAM,CAACC,cAAP,CAAsBH,KAAtB,MAAiCC,KAAxC;;;SChBcG,oBAAoBC,UAAkBC;MAChDC,OAAO,GAAG,CAAd;SACO;IACLC,WADK,uBACUC,EADV;UAEGC,OAAO,GAAGC,IAAI,CAACC,GAAL,EAAhB;;UACI;eACKH,EAAE,EAAT;OADF,SAEU;YACFI,QAAQ,GAAGF,IAAI,CAACC,GAAL,EAAjB;QACAL,OAAO,IAAIM,QAAQ,GAAGH,OAAtB;;KAPC;IAULI,cAVK;UAWCP,OAAO,GAAGF,QAAd,EAAwB;QACtBU,OAAO,CAACC,IAAR,CAAgBV,MAAhB,cAA+BC,OAA/B,wDAAyFF,QAAzF;;;GAZN;;;ACIF,IAAMY,MAAM,GAAW,kBAAvB;;;;AAKA,SAASC,SAAT,CAAmBC,SAAnB,EAAmCC,OAAnC;MACMD,SAAJ,EAAe;;;AAKf,AAMA;;;QACM,IAAIE,KAAJ,CAAaJ,MAAb,WAAwBG,OAAO,IAAI,EAAnC,EAAN;;;AAGF,SAASE,SAAT,CACEC,GADF,EAEEC,UAFF,EAGEC,MAHF,EAIEC,QAJF;SAMSC,IAAI,CAACL,SAAL,CAAeC,GAAf,EAAoBK,YAAY,CAACJ,UAAD,EAAaE,QAAb,CAAhC,EAAwDD,MAAxD,CAAP;;;AAGF,SAASG,YAAT,CACEJ,UADF,EAEEE,QAFF;MAIMG,KAAK,GAAU,EAAnB;MACEC,IAAI,GAAU,EADhB;MAGI,CAACJ,QAAL,EACEA,QAAQ,GAAG,kBAASK,CAAT,EAAoB/B,KAApB;QACL6B,KAAK,CAAC,CAAD,CAAL,KAAa7B,KAAjB,EAAwB,OAAO,cAAP;WAEtB,iBAAiB8B,IAAI,CAACE,KAAL,CAAW,CAAX,EAAcH,KAAK,CAACI,OAAN,CAAcjC,KAAd,CAAd,EAAoCkC,IAApC,CAAyC,GAAzC,CAAjB,GAAiE,GADnE;GAFF;SAOK,UAAoBC,GAApB,EAAiCnC,KAAjC;QACD6B,KAAK,CAAClC,MAAN,GAAe,CAAnB,EAAsB;UAChByC,OAAO,GAAGP,KAAK,CAACI,OAAN,CAAc,IAAd,CAAd;OACCG,OAAD,GAAWP,KAAK,CAACQ,MAAN,CAAaD,OAAO,GAAG,CAAvB,CAAX,GAAuCP,KAAK,CAACS,IAAN,CAAW,IAAX,CAAvC;OACCF,OAAD,GAAWN,IAAI,CAACO,MAAL,CAAYD,OAAZ,EAAqBG,QAArB,EAA+BJ,GAA/B,CAAX,GAAiDL,IAAI,CAACQ,IAAL,CAAUH,GAAV,CAAjD;UACI,CAACN,KAAK,CAACI,OAAN,CAAcjC,KAAd,CAAL,EAA2BA,KAAK,GAAG0B,QAAS,CAACc,IAAV,CAAe,IAAf,EAAqBL,GAArB,EAA0BnC,KAA1B,CAAR;KAJ7B,MAKO6B,KAAK,CAACS,IAAN,CAAWtC,KAAX;;WAEAwB,UAAU,IAAI,IAAd,GAAqBxB,KAArB,GAA6BwB,UAAU,CAACgB,IAAX,CAAgB,IAAhB,EAAsBL,GAAtB,EAA2BnC,KAA3B,CAApC;GARF;;;;;;;;;AAiBF,SAAgByC,mBAAmBzC;SAE/B,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAAvC,IAA+C,OAAOA,KAAP,KAAiB,WADlE;;AAKF,SAAgB0C,kBACdC,aACAC,aACArB;MAEMsB,iBAAiB,GAAGC,eAAe,CAACH,WAAD,EAAcC,WAAd,EAA2BrB,GAA3B,CAAzC;SACO;IACLwB,eADK;aAEIA,gBAAe,CAACJ,WAAD,EAAcC,WAAd,EAA2BC,iBAA3B,EAA8CtB,GAA9C,CAAtB;;GAFJ;;;AAYF,SAASuB,eAAT,CACEH,WADF,EAEEC,WAFF,EAGErB,GAHF,EAIEyB,IAJF;MAEEJ;IAAAA,cAA2B;;;MAE3BI;IAAAA,OAAiB;;;MAEXC,OAAO,GAA6B;IAAEjD,KAAK,EAAEuB;GAAnD;;MAEI,CAACoB,WAAW,CAACpB,GAAD,CAAhB,EAAuB;IACrB0B,OAAO,CAACC,QAAR,GAAmB,EAAnB;;SAEK,IAAMf,GAAX,IAAkBZ,GAAlB,EAAuB;UACf4B,SAAS,GAAGH,IAAI,CAACI,MAAL,CAAYjB,GAAZ,CAAlB;;UAEES,WAAW,CAACjD,MAAZ,IACAiD,WAAW,CAACX,OAAZ,CAAoBkB,SAAS,CAACjB,IAAV,CAAe,GAAf,CAApB,MAA6C,CAAC,CAFhD,EAGE;;;;MAIFe,OAAO,CAACC,QAAR,CAAiBf,GAAjB,IAAwBW,eAAe,CACrCH,WADqC,EAErCC,WAFqC,EAGrCrB,GAAG,CAACY,GAAD,CAHkC,EAIrCgB,SAJqC,CAAvC;;;;SAQGF,OAAP;;;AAKF,SAASF,gBAAT,CACEJ,WADF,EAEEC,WAFF,EAGES,eAHF,EAIE9B,GAJF,EAKE+B,aALF,EAMEN,IANF;MAEEJ;IAAAA,cAA2B;;;MAG3BU;IAAAA,gBAAyB;;;MACzBN;IAAAA,OAAiB;;;MAEXO,OAAO,GAAGF,eAAe,GAAGA,eAAe,CAACrD,KAAnB,GAA2BJ,SAA1D;MAEM4D,OAAO,GAAGD,OAAO,KAAKhC,GAA5B;;MAEI+B,aAAa,IAAI,CAACE,OAAlB,IAA6B,CAACC,MAAM,CAACC,KAAP,CAAanC,GAAb,CAAlC,EAAqD;WAC5C;MAAEoC,UAAU,EAAE,IAAd;MAAoBX,IAAI,EAAJA;KAA3B;;;MAGEL,WAAW,CAACY,OAAD,CAAX,IAAwBZ,WAAW,CAACpB,GAAD,CAAvC,EAA8C;WACrC;MAAEoC,UAAU,EAAE;KAArB;;;;MAIIC,YAAY,GAA4B,EAA9C;EACA1D,MAAM,CAAC4B,IAAP,CAAYuB,eAAe,CAACH,QAA5B,EAAsCW,OAAtC,CAA8C,UAAA1B,GAAG;IAC/CyB,YAAY,CAACzB,GAAD,CAAZ,GAAoB,IAApB;GADF;EAGAjC,MAAM,CAAC4B,IAAP,CAAYP,GAAZ,EAAiBsC,OAAjB,CAAyB,UAAA1B,GAAG;IAC1ByB,YAAY,CAACzB,GAAD,CAAZ,GAAoB,IAApB;GADF;MAIML,IAAI,GAAG5B,MAAM,CAAC4B,IAAP,CAAY8B,YAAZ,CAAb;;OACK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhC,IAAI,CAACnC,MAAzB,EAAiCmE,CAAC,EAAlC,EAAsC;QAC9B3B,GAAG,GAAGL,IAAI,CAACgC,CAAD,CAAhB;QACMX,SAAS,GAAGH,IAAI,CAACI,MAAL,CAAYjB,GAAZ,CAAlB;;QACIS,WAAW,CAACjD,MAAZ,IAAsBiD,WAAW,CAACX,OAAZ,CAAoBkB,SAAS,CAACjB,IAAV,CAAe,GAAf,CAApB,MAA6C,CAAC,CAAxE,EAA2E;;;;QAIrE6B,MAAM,GAAGhB,gBAAe,CAC5BJ,WAD4B,EAE5BC,WAF4B,EAG5BS,eAAe,CAACH,QAAhB,CAAyBf,GAAzB,CAH4B,EAI5BZ,GAAG,CAACY,GAAD,CAJyB,EAK5BqB,OAL4B,EAM5BL,SAN4B,CAA9B;;QASIY,MAAM,CAACJ,UAAX,EAAuB;aACdI,MAAP;;;;SAGG;IAAEJ,UAAU,EAAE;GAArB;;;;;;;;;;;;;AA0BF,SAAgBK,wCACdC;MAAAA;IAAAA,UAAoD;;;iBAWhDA;sCAJFtB;MAAAA,gDAAcF;MACdyB,wBAAAA;oCACAC;MAAAA,4CAAY;MACZC,kBAAAA;;EAIFF,YAAY,GAAGA,YAAY,IAAIE,MAA/B;MAEMC,KAAK,GAAG3B,iBAAiB,CAAC4B,IAAlB,CAAuB,IAAvB,EAA6B3B,WAA7B,EAA0CuB,YAA1C,CAAd;SAEO;QAAGK,gBAAAA;QACJC,KAAK,GAAGD,QAAQ,EAApB;QACIE,OAAO,GAAGJ,KAAK,CAACG,KAAD,CAAnB;QAEIT,MAAJ;WACO,UAAAW,IAAI;aAAI,UAAAC,MAAM;YACbC,YAAY,GAAGxE,mBAAmB,CACtC+D,SADsC,EAEtC,mCAFsC,CAAxC;QAKAS,YAAY,CAACpE,WAAb,CAAyB;UACvBgE,KAAK,GAAGD,QAAQ,EAAhB;UAEAR,MAAM,GAAGU,OAAO,CAAC1B,eAAR,EAAT;;UAEA0B,OAAO,GAAGJ,KAAK,CAACG,KAAD,CAAf;WAGE,CAACT,MAAM,CAACJ,UADV,IAAAzC,SAAS,4EAE2D,CAChE6C,MAAM,CAACf,IAAP,IAAe,EADiD,EAEhEd,IAFgE,CAGhE,GAHgE,CAF3D,2HAAT,CAAA;SAPF;YAiBM2C,gBAAgB,GAAGH,IAAI,CAACC,MAAD,CAA7B;QAEAC,YAAY,CAACpE,WAAb,CAAyB;UACvBgE,KAAK,GAAGD,QAAQ,EAAhB;UAEAR,MAAM,GAAGU,OAAO,CAAC1B,eAAR,EAAT;;UAEA0B,OAAO,GAAGJ,KAAK,CAACG,KAAD,CAAf;UAEAT,MAAM,CAACJ,UAAP,MAEI,CAACI,MAAM,CAACJ,UAFZ,IACEzC,SADF,2EAGqE,CAC/D6C,MAAM,CAACf,IAAP,IAAe,EADgD,EAE/Dd,IAF+D,CAG/D,GAH+D,CAHrE,4DAO4DZ,SAAS,CAC/DqD,MAD+D,CAPrE;SAPF;QAoBAC,YAAY,CAAC9D,cAAb;eAEO+D,gBAAP;OA/CS;KAAX;GALF;;;ACxNF;;;;;;;;;;AASA,SAAgBC,QAAQC;SAEpB,OAAOA,GAAP,KAAe,WAAf,IACAA,GAAG,KAAK,IADR,IAEA,OAAOA,GAAP,KAAe,QAFf,IAGA,OAAOA,GAAP,KAAe,SAHf,IAIA,OAAOA,GAAP,KAAe,QAJf,IAKAC,KAAK,CAACC,OAAN,CAAcF,GAAd,CALA,IAMAhF,aAAa,CAACgF,GAAD,CAPf;;;;;;AAmBF,SAAgBG,yBACdlF,OACAgD,MACAmC,gBACAC,YACAlB;MAHAlB;IAAAA,OAA8B;;;MAC9BmC;IAAAA,iBAA8CL;;;MAE9CZ;IAAAA,eAAyB;;;MAErBmB,uBAAJ;;MAEI,CAACF,cAAc,CAACnF,KAAD,CAAnB,EAA4B;WACnB;MACLsF,OAAO,EAAEtC,IAAI,CAACd,IAAL,CAAU,GAAV,KAAkB,QADtB;MAELlC,KAAK,EAAEA;KAFT;;;MAME,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD;WACxC,KAAP;;;MAGIuF,OAAO,GAAGH,UAAU,IAAI,IAAd,GAAqBA,UAAU,CAACpF,KAAD,CAA/B,GAAyCE,MAAM,CAACqF,OAAP,CAAevF,KAAf,CAAzD;MAEMwF,eAAe,GAAGtB,YAAY,CAACvE,MAAb,GAAsB,CAA9C;;uBAEsC4F,OAAtC,kHAA+C;;;;;;;;;;;;;QAAnCE,QAAmC;QAAzBC,WAAyB;QACvCC,UAAU,GAAG3C,IAAI,CAACI,MAAL,CAAYqC,QAAZ,CAAnB;;QAEID,eAAe,IAAItB,YAAY,CAACjC,OAAb,CAAqB0D,UAAU,CAACzD,IAAX,CAAgB,GAAhB,CAArB,KAA8C,CAArE,EAAwE;;;;QAIpE,CAACiD,cAAc,CAACO,WAAD,CAAnB,EAAkC;aACzB;QACLJ,OAAO,EAAEK,UAAU,CAACzD,IAAX,CAAgB,GAAhB,CADJ;QAELlC,KAAK,EAAE0F;OAFT;;;QAME,OAAOA,WAAP,KAAuB,QAA3B,EAAqC;MACnCL,uBAAuB,GAAGH,wBAAwB,CAChDQ,WADgD,EAEhDC,UAFgD,EAGhDR,cAHgD,EAIhDC,UAJgD,EAKhDlB,YALgD,CAAlD;;UAQImB,uBAAJ,EAA6B;eACpBA,uBAAP;;;;;SAKC,KAAP;;;;;;;;;;;;AAmDF,SAAgBO,2CACd3B;MAAAA;IAAAA,UAAuD;;;iBAYnDA;uCANFkB;MAAAA,oDAAiBL;MACjBM,sBAAAA;uCACAS;MAAAA,oDAAiB;wCACjBC;MAAAA,yDAAqB,CAAC,UAAD;uCACrB5B;MAAAA,kDAAe;oCACfC;MAAAA,4CAAY;SAGP,UAAA4B,QAAQ;WAAI,UAAArB,IAAI;aAAI,UAAAC,MAAM;YAC3BkB,cAAc,CAAClG,MAAf,IAAyBkG,cAAc,CAAC5D,OAAf,CAAuB0C,MAAM,CAACqB,IAA9B,MAAwC,CAAC,CAAtE,EAAyE;iBAChEtB,IAAI,CAACC,MAAD,CAAX;;;YAGIC,YAAY,GAAGxE,mBAAmB,CACtC+D,SADsC,EAEtC,sCAFsC,CAAxC;QAIAS,YAAY,CAACpE,WAAb,CAAyB;cACjByF,+BAA+B,GAAGf,wBAAwB,CAC9DP,MAD8D,EAE9D,EAF8D,EAG9DQ,cAH8D,EAI9DC,UAJ8D,EAK9DU,kBAL8D,CAAhE;;cAQIG,+BAAJ,EAAqC;gBAC3BX,OAD2B,GACRW,+BADQ,CAC3BX,OAD2B;gBAClBtF,KADkB,GACRiG,+BADQ,CAClBjG,KADkB;YAGnCe,OAAO,CAACmF,KAAR,wEACwEZ,OADxE,gBAEEtF,KAFF,EAGE,0DAHF,EAIE2E,MAJF,EAKE,uIALF;;SAZJ;YAsBMZ,MAAM,GAAGW,IAAI,CAACC,MAAD,CAAnB;QAEAC,YAAY,CAACpE,WAAb,CAAyB;cACjBgE,KAAK,GAAGuB,QAAQ,CAACxB,QAAT,EAAd;cAEM4B,8BAA8B,GAAGjB,wBAAwB,CAC7DV,KAD6D,EAE7D,EAF6D,EAG7DW,cAH6D,EAI7DC,UAJ6D,EAK7DlB,YAL6D,CAA/D;;cAQIiC,8BAAJ,EAAoC;gBAC1Bb,OAD0B,GACPa,8BADO,CAC1Bb,OAD0B;gBACjBtF,KADiB,GACPmG,8BADO,CACjBnG,KADiB;YAGlCe,OAAO,CAACmF,KAAR,wEACwEZ,OADxE,gBAEEtF,KAFF,kEAImD2E,MAAM,CAACqB,IAJ1D;;SAdJ;QAwBApB,YAAY,CAAC9D,cAAb;eAEOiD,MAAP;OA3DqB;KAAR;GAAf;;;AC1IF,SAASqC,SAAT,CAAmBC,CAAnB;SACS,OAAOA,CAAP,KAAa,SAApB;;;;;;;;;;;;;AAmCF,SAAgBC,qBAOdrC;MAAAA;IAAAA,UAAa;;;iBAKTA;gCAHFsC;MAAAA,oCAAQ;uCACRC;MAAAA,oDAAiB;uCACjBC;MAAAA,uDAAoB;MAGlBC,eAAe,GAAwB,EAA3C;;MAEIH,KAAJ,EAAW;QACLH,SAAS,CAACG,KAAD,CAAb,EAAsB;MACpBG,eAAe,CAACpE,IAAhB,CAAqBqE,eAArB;KADF,MAEO;MACLD,eAAe,CAACpE,IAAhB,CACEqE,eAAe,CAACC,iBAAhB,CAAkCL,KAAK,CAACM,aAAxC,CADF;;;;EAMuC;QACrCL,cAAJ,EAAoB;;UAEdM,gBAAgB,GAA6C,EAAjE;;UAEI,CAACV,SAAS,CAACI,cAAD,CAAd,EAAgC;QAC9BM,gBAAgB,GAAGN,cAAnB;;;MAGFE,eAAe,CAACK,OAAhB,CACE/C,uCAAuC,CAAC8C,gBAAD,CADzC;;;;QAMEL,iBAAJ,EAAuB;UACjBO,mBAAmB,GAAgD,EAAvE;;UAEI,CAACZ,SAAS,CAACK,iBAAD,CAAd,EAAmC;QACjCO,mBAAmB,GAAGP,iBAAtB;;;MAGFC,eAAe,CAACpE,IAAhB,CACEsD,0CAA0C,CAACoB,mBAAD,CAD5C;;;;SAMGN,eAAP;;;AC7EF,IAAMO,aAAa,GAAGC,aAAA,KAAyB,YAA/C;;;;;;;;;;AA8FA,SAAgBC,eAIdlD;aAOIA,OAAO,IAAI;0BALbmD;MAAAA,oCAAUxH;6BACVyH;MAAAA,0CAAaf,oBAAoB;2BACjCgB;MAAAA,sCAAW;iCACXC;MAAAA,kDAAiB3H;4BACjB4H;MAAAA,wCAAY5H;;MAGV6H,WAAJ;;MAEI,OAAOL,OAAP,KAAmB,UAAvB,EAAmC;IACjCK,WAAW,GAAGL,OAAd;GADF,MAEO,IAAIrH,aAAa,CAACqH,OAAD,CAAjB,EAA4B;IACjCK,WAAW,GAAGC,qBAAe,CAACN,OAAD,CAA7B;GADK,MAEA;UACC,IAAI/F,KAAJ,CACJ,0HADI,CAAN;;;MAKIsG,kBAAkB,GAAGC,qBAAe,MAAf,SAAmBP,UAAnB,CAA3B;MAEIQ,YAAY,GAAGhI,aAAnB;;MAEIyH,QAAJ,EAAc;IACZO,YAAY,GAAGtI,mBAAmB;;MAEhCuI,KAAK,EAAE,CAACb;OACJ,OAAOK,QAAP,KAAoB,QAApB,IAAgCA,QAHJ,EAAlC;;;MAOES,cAAc,GAAoB,CAACJ,kBAAD,CAAtC;;MAEI3C,KAAK,CAACC,OAAN,CAAcuC,SAAd,CAAJ,EAA8B;IAC5BO,cAAc,IAAIJ,kBAAJ,SAA2BH,SAA3B,CAAd;GADF,MAEO,IAAI,OAAOA,SAAP,KAAqB,UAAzB,EAAqC;IAC1CO,cAAc,GAAGP,SAAS,CAACO,cAAD,CAA1B;;;MAGIC,gBAAgB,GAAGH,YAAY,MAAZ,SAAgBE,cAAhB,CAAzB;SAEOE,iBAAW,CAChBR,WADgB,EAEhBF,cAFgB,EAGhBS,gBAHgB,CAAlB;;;SC4FcE,aAAalC,MAAcmC;WAChCC,aAAT;QACMD,aAAJ,EAAmB;UACbE,QAAQ,GAAGF,aAAa,MAAb,mBAAf;;UACI,CAACE,QAAL,EAAe;cACP,IAAIhH,KAAJ,CAAU,wCAAV,CAAN;;;;QAIA2E,IAAI,EAAJA,IADF;QAEEsC,OAAO,EAAED,QAAQ,CAACC;SACd,UAAUD,QAAV,IAAsB;QAAEE,IAAI,EAAEF,QAAQ,CAACE;OAH7C,MAIM,WAAWF,QAAX,IAAuB;QAAEnC,KAAK,EAAEmC,QAAQ,CAACnC;OAJ/C;;;WAOK;MAAEF,IAAI,EAAJA,IAAF;MAAQsC,OAAO;KAAtB;;;EAGFF,aAAa,CAACI,QAAd,GAAyB;gBAASxC,IAAT;GAAzB;;EAEAoC,aAAa,CAACpC,IAAd,GAAqBA,IAArB;;EAEAoC,aAAa,CAACK,KAAd,GAAsB,UAAC9D,MAAD;WACpBA,MAAM,CAACqB,IAAP,KAAgBA,IADI;GAAtB;;SAGOoC,aAAP;;AAGF,SAAgBM,MACd/D;SAQE5E,aAAa,CAAC4E,MAAD,CAAb,IACA,OAAQA,MAAc,CAACqB,IAAvB,KAAgC,QADhC,IAEA9F,MAAM,CAAC4B,IAAP,CAAY6C,MAAZ,EAAoBgE,KAApB,CAA0BC,UAA1B,CAHF;;;AAOF,SAASA,UAAT,CAAoBzG,GAApB;SACS,CAAC,MAAD,EAAS,SAAT,EAAoB,OAApB,EAA6B,MAA7B,EAAqCF,OAArC,CAA6CE,GAA7C,IAAoD,CAAC,CAA5D;;;;;;;;;;;;;;AAaF,SAAgB0G,QACdT;cAEUA,aAAV;;;SC9RcU,8BACdC;MAEMC,UAAU,GAAyB,EAAzC;MACMC,OAAO,GAAG;IACdC,OADc,mBAEZC,mBAFY,EAGZ/B,OAHY;UAKNpB,IAAI,GACR,OAAOmD,mBAAP,KAA+B,QAA/B,GACIA,mBADJ,GAEIA,mBAAmB,CAACnD,IAH1B;;UAIIA,IAAI,IAAIgD,UAAZ,EAAwB;cAChB,IAAI3H,KAAJ,CACJ,qEADI,CAAN;;;MAIF2H,UAAU,CAAChD,IAAD,CAAV,GAAmBoB,OAAnB;aACO6B,OAAP;;GAfJ;EAkBAF,eAAe,CAACE,OAAD,CAAf;SACOD,UAAP;;;SCsCcI,cACdC,cACAC;MAIIN,UAAU,GACZ,OAAOM,oBAAP,KAAgC,UAAhC,GACIR,6BAA6B,CAACQ,oBAAD,CADjC,GAEIA,oBAHN;SAKO,UAAS9E,KAAT,EAA+BG,MAA/B;QAASH;MAAAA,QAAQ6E;;;;;;WAIfE,wBAAe,CAAC/E,KAAD,EAAQ,UAACgF,KAAD;UACtBC,WAAW,GAAGT,UAAU,CAACrE,MAAM,CAACqB,IAAR,CAA9B;aACOyD,WAAW,GAAGA,WAAW,CAACD,KAAD,EAAQ7E,MAAR,CAAd,GAAgC/E,SAAlD;KAFoB,CAAtB;GAJF;;;AC+FF,SAASiJ,SAAT,CAAiB7G,KAAjB,EAAgC0H,SAAhC;SACY1H,KAAV,SAAmB0H,SAAnB;;;;;;;;;;;;;;AAaF,SAAgBC,YAKd1F;MAEQ2F,OAAuB3F,QAAvB2F;MAAMP,eAAiBpF,QAAjBoF;;MACV,CAACO,IAAL,EAAW;UACH,IAAIvI,KAAJ,CAAU,6CAAV,CAAN;;;MAEIwI,QAAQ,GAAG5F,OAAO,CAAC4F,QAAR,IAAoB,EAArC;MACMC,aAAa,GACjB,OAAO7F,OAAO,CAAC6F,aAAf,KAAiC,WAAjC,GACI,EADJ,GAEI,OAAO7F,OAAO,CAAC6F,aAAf,KAAiC,UAAjC,GACAhB,6BAA6B,CAAC7E,OAAO,CAAC6F,aAAT,CAD7B,GAEA7F,OAAO,CAAC6F,aALd;MAOMC,YAAY,GAAG7J,MAAM,CAAC4B,IAAP,CAAY+H,QAAZ,CAArB;MAEMG,uBAAuB,GAAgC,EAA7D;MACMC,uBAAuB,GAAgC,EAA7D;MACMC,cAAc,GAA6B,EAAjD;EAEAH,YAAY,CAAClG,OAAb,CAAqB,UAAAsG,WAAW;QACxBC,uBAAuB,GAAGP,QAAQ,CAACM,WAAD,CAAxC;QACMnE,IAAI,GAAG6C,SAAO,CAACe,IAAD,EAAOO,WAAP,CAApB;QAEIV,WAAJ;QACIY,eAAJ;;QAEI,aAAaD,uBAAjB,EAA0C;MACxCX,WAAW,GAAGW,uBAAuB,CAAChD,OAAtC;MACAiD,eAAe,GAAGD,uBAAuB,CAACE,OAA1C;KAFF,MAGO;MACLb,WAAW,GAAGW,uBAAd;;;IAGFJ,uBAAuB,CAACG,WAAD,CAAvB,GAAuCV,WAAvC;IACAQ,uBAAuB,CAACjE,IAAD,CAAvB,GAAgCyD,WAAhC;IACAS,cAAc,CAACC,WAAD,CAAd,GAA8BE,eAAe,GACzCnC,YAAY,CAAClC,IAAD,EAAOqE,eAAP,CAD6B,GAEzCnC,YAAY,CAAClC,IAAD,CAFhB;GAhBF;;MAqBMuE,iBAAiB,gBAAQT,aAAR,MAA0BG,uBAA1B,CAAvB;;MACM7C,OAAO,GAAGgC,aAAa,CAACC,YAAD,EAAekB,iBAAf,CAA7B;SAEO;IACLX,IAAI,EAAJA,IADK;IAELxC,OAAO,EAAPA,OAFK;IAGLoD,OAAO,EAAEN,cAHJ;IAILO,YAAY,EAAET;GAJhB;;;SCtQcU;SACP;IACLC,GAAG,EAAE,EADA;IAELC,QAAQ,EAAE;GAFZ;;AAMF,SAAgBC;WAKLC,eAAT,CAAyBC,eAAzB;QAAyBA;MAAAA,kBAAuB;;;WACvC7K,MAAM,CAAC8K,MAAP,CAAcN,qBAAqB,EAAnC,EAAuCK,eAAvC,CAAP;;;SAGK;IAAED,eAAe,EAAfA;GAAT;;;SCfcG;WAKLC,YAAT,CACEC,WADF;QAGQC,SAAS,GAAG,SAAZA,SAAY,CAAC5G,KAAD;aAAgBA,KAAK,CAACmG,GAAtB;KAAlB;;QAEMU,cAAc,GAAG,SAAjBA,cAAiB,CAAC7G,KAAD;aAA2BA,KAAK,CAACoG,QAAjC;KAAvB;;QAEMU,SAAS,GAAGC,uBAAc,CAC9BH,SAD8B,EAE9BC,cAF8B,EAG9B,UAACV,GAAD,EAAWC,QAAX;aACED,GAAG,CAACa,GAAJ,CAAQ,UAACC,EAAD;eAAcb,QAAgB,CAACa,EAAD,CAA9B;OAAR,CADF;KAH8B,CAAhC;;QAOMC,QAAQ,GAAG,SAAXA,QAAW,CAAC3J,CAAD,EAAS0J,EAAT;aAA0BA,EAA1B;KAAjB;;QAEME,UAAU,GAAG,SAAbA,UAAa,CAACf,QAAD,EAA0Ba,EAA1B;aAA2Cb,QAAQ,CAACa,EAAD,CAAnD;KAAnB;;QAEMG,WAAW,GAAGL,uBAAc,CAACH,SAAD,EAAY,UAAAT,GAAG;aAAIA,GAAG,CAAChL,MAAR;KAAf,CAAlC;;QAEI,CAACwL,WAAL,EAAkB;aACT;QACLC,SAAS,EAATA,SADK;QAELC,cAAc,EAAdA,cAFK;QAGLC,SAAS,EAATA,SAHK;QAILM,WAAW,EAAXA,WAJK;QAKLD,UAAU,EAAEJ,uBAAc,CAACF,cAAD,EAAiBK,QAAjB,EAA2BC,UAA3B;OAL5B;;;QASIE,wBAAwB,GAAGN,uBAAc,CAACJ,WAAD,EAAcE,cAAd,CAA/C;WAEO;MACLD,SAAS,EAAEG,uBAAc,CAACJ,WAAD,EAAcC,SAAd,CADpB;MAELC,cAAc,EAAEQ,wBAFX;MAGLP,SAAS,EAAEC,uBAAc,CAACJ,WAAD,EAAcG,SAAd,CAHpB;MAILM,WAAW,EAAEL,uBAAc,CAACJ,WAAD,EAAcS,WAAd,CAJtB;MAKLD,UAAU,EAAEJ,uBAAc,CAACM,wBAAD,EAA2BH,QAA3B,EAAqCC,UAArC;KAL5B;;;SASK;IAAET,YAAY,EAAZA;GAAT;;;SC7CcY,oBACdC;SAEO,SAASC,SAAT,CACLxH,KADK,EAELyH,GAFK;aAIIC,uBAAT,CACED,GADF;aAGSvD,KAAK,CAACuD,GAAD,CAAZ;;;QAGIE,UAAU,GAAG,SAAbA,UAAa,CAAC3C,KAAD;UACb0C,uBAAuB,CAACD,GAAD,CAA3B,EAAkC;QAChCF,OAAO,CAACE,GAAG,CAAC3D,OAAL,EAAckB,KAAd,CAAP;OADF,MAEO;QACLuC,OAAO,CAACE,GAAD,EAAMzC,KAAN,CAAP;;KAJJ;;QAQI4C,uBAAO,CAAC5H,KAAD,CAAX,EAAoB;;;;MAIlB2H,UAAU,CAAC3H,KAAD,CAAV,CAJkB;;aAOXA,KAAP;KAPF,MAQO;;;;aAIE+E,wBAAe,CAAC/E,KAAD,EAAQ2H,UAAR,CAAtB;;GA9BJ;;;SCLcE,cAAiBC,QAAWZ;MACpCvJ,GAAG,GAAGuJ,QAAQ,CAACY,MAAD,CAApB;;MAEIpF,CAAyC/E,GAAG,KAAKvC,SAArD,EAAgE;IAC9DmB,OAAO,CAACC,IAAR,CACE,wEADF,EAEE,iEAFF,EAGE,6BAHF,EAIEsL,MAJF,EAKE,gCALF,EAMEZ,QAAQ,CAAClD,QAAT,EANF;;;SAUKrG,GAAP;;;SCNcoK,2BACdb;WAISc,aAAT,CAAuBF,MAAvB,EAAkC9H,KAAlC;QACQrC,GAAG,GAAGkK,aAAa,CAACC,MAAD,EAASZ,QAAT,CAAzB;;QAEIvJ,GAAG,IAAIqC,KAAK,CAACoG,QAAjB,EAA2B;;;;IAI3BpG,KAAK,CAACmG,GAAN,CAAUrI,IAAV,CAAeH,GAAf;IACAqC,KAAK,CAACoG,QAAN,CAAezI,GAAf,IAAsBmK,MAAtB;;;WAGOG,cAAT,CAAwB7B,QAAxB,EAA6DpG,KAA7D;QACM,CAACQ,KAAK,CAACC,OAAN,CAAc2F,QAAd,CAAL,EAA8B;MAC5BA,QAAQ,GAAG1K,MAAM,CAACwM,MAAP,CAAc9B,QAAd,CAAX;;;yBAGmBA,QAArB,kHAA+B;;;;;;;;;;;;UAApB0B,MAAoB;MAC7BE,aAAa,CAACF,MAAD,EAAS9H,KAAT,CAAb;;;;WAIKmI,aAAT,CAAuB/B,QAAvB,EAA4DpG,KAA5D;QACM,CAACQ,KAAK,CAACC,OAAN,CAAc2F,QAAd,CAAL,EAA8B;MAC5BA,QAAQ,GAAG1K,MAAM,CAACwM,MAAP,CAAc9B,QAAd,CAAX;;;IAGFpG,KAAK,CAACmG,GAAN,GAAY,EAAZ;IACAnG,KAAK,CAACoG,QAAN,GAAiB,EAAjB;IAEA6B,cAAc,CAAC7B,QAAD,EAAWpG,KAAX,CAAd;;;WAGOoI,gBAAT,CAA0BzK,GAA1B,EAAyCqC,KAAzC;WACSqI,iBAAiB,CAAC,CAAC1K,GAAD,CAAD,EAAQqC,KAAR,CAAxB;;;WAGOqI,iBAAT,CAA2B/K,IAA3B,EAA6C0C,KAA7C;QACMsI,SAAS,GAAG,KAAhB;IAEAhL,IAAI,CAAC+B,OAAL,CAAa,UAAA1B,GAAG;UACVA,GAAG,IAAIqC,KAAK,CAACoG,QAAjB,EAA2B;eAClBpG,KAAK,CAACoG,QAAN,CAAezI,GAAf,CAAP;QACA2K,SAAS,GAAG,IAAZ;;KAHJ;;QAOIA,SAAJ,EAAe;MACbtI,KAAK,CAACmG,GAAN,GAAYnG,KAAK,CAACmG,GAAN,CAAUoC,MAAV,CAAiB,UAAAtB,EAAE;eAAIA,EAAE,IAAIjH,KAAK,CAACoG,QAAhB;OAAnB,CAAZ;;;;WAIKoC,SAAT,CAAmBxI,KAAnB;WACStE,MAAM,CAAC8K,MAAP,CAAc,EAAd,EAAkBxG,KAAlB,EAAyB;MAC9BmG,GAAG,EAAE,EADyB;MAE9BC,QAAQ,EAAE;KAFL,CAAP;;;WAMOqC,UAAT,CACEnL,IADF,EAEEoL,MAFF,EAGE1I,KAHF;QAKQ2I,QAAQ,GAAG3I,KAAK,CAACoG,QAAN,CAAesC,MAAM,CAACzB,EAAtB,CAAjB;QACM2B,OAAO,GAAMlN,MAAM,CAAC8K,MAAP,CAAc,EAAd,EAAkBmC,QAAlB,EAA4BD,MAAM,CAACG,OAAnC,CAAnB;QACMC,MAAM,GAAGjB,aAAa,CAACe,OAAD,EAAU1B,QAAV,CAA5B;QACM6B,SAAS,GAAGD,MAAM,KAAKJ,MAAM,CAACzB,EAApC;;QAEI8B,SAAJ,EAAe;MACbzL,IAAI,CAACoL,MAAM,CAACzB,EAAR,CAAJ,GAAkB6B,MAAlB;aACO9I,KAAK,CAACoG,QAAN,CAAesC,MAAM,CAACzB,EAAtB,CAAP;;;IAGFjH,KAAK,CAACoG,QAAN,CAAe0C,MAAf,IAAyBF,OAAzB;WAEOG,SAAP;;;WAGOC,gBAAT,CAA0BN,MAA1B,EAA6C1I,KAA7C;WACSiJ,iBAAiB,CAAC,CAACP,MAAD,CAAD,EAAW1I,KAAX,CAAxB;;;WAGOiJ,iBAAT,CAA2BC,OAA3B,EAAiDlJ,KAAjD;QACQmJ,OAAO,GAA+B,EAA5C;QAEMC,gBAAgB,GAAgC,EAAtD;IAEAF,OAAO,CAAC7J,OAAR,CAAgB,UAAAqJ,MAAM;;UAEhBA,MAAM,CAACzB,EAAP,IAAajH,KAAK,CAACoG,QAAvB,EAAiC;;QAE/BgD,gBAAgB,CAACV,MAAM,CAACzB,EAAR,CAAhB,gBAGKmC,gBAAgB,CAACV,MAAM,CAACzB,EAAR,CAHrB,MAIKyB,MAJL;;KAJJ;IAaAQ,OAAO,GAAGxN,MAAM,CAACwM,MAAP,CAAckB,gBAAd,CAAV;QAEMC,iBAAiB,GAAGH,OAAO,CAAC/N,MAAR,GAAiB,CAA3C;;QAEIkO,iBAAJ,EAAuB;UACfC,YAAY,GAChBJ,OAAO,CAACX,MAAR,CAAe,UAAAG,MAAM;eAAID,UAAU,CAACU,OAAD,EAAUT,MAAV,EAAkB1I,KAAlB,CAAd;OAArB,EAA6D7E,MAA7D,GAAsE,CADxE;;UAGImO,YAAJ,EAAkB;QAChBtJ,KAAK,CAACmG,GAAN,GAAYnG,KAAK,CAACmG,GAAN,CAAUa,GAAV,CAAc,UAAAC,EAAE;iBAAIkC,OAAO,CAAClC,EAAD,CAAP,IAAeA,EAAnB;SAAhB,CAAZ;;;;;WAKGsC,gBAAT,CAA0BzB,MAA1B,EAAqC9H,KAArC;WACSwJ,iBAAiB,CAAC,CAAC1B,MAAD,CAAD,EAAW9H,KAAX,CAAxB;;;WAGOwJ,iBAAT,CACEpD,QADF,EAEEpG,KAFF;QAIM,CAACQ,KAAK,CAACC,OAAN,CAAc2F,QAAd,CAAL,EAA8B;MAC5BA,QAAQ,GAAG1K,MAAM,CAACwM,MAAP,CAAc9B,QAAd,CAAX;;;QAGIqD,KAAK,GAAQ,EAAnB;QACMb,OAAO,GAAgB,EAA7B;;0BAEqBxC,QAArB,yHAA+B;;;;;;;;;;;;UAApB0B,MAAoB;UACvBb,EAAE,GAAGY,aAAa,CAACC,MAAD,EAASZ,QAAT,CAAxB;;UACID,EAAE,IAAIjH,KAAK,CAACoG,QAAhB,EAA0B;QACxBwC,OAAO,CAAC9K,IAAR,CAAa;UAAEmJ,EAAE,EAAFA,EAAF;UAAM4B,OAAO,EAAEf;SAA5B;OADF,MAEO;QACL2B,KAAK,CAAC3L,IAAN,CAAWgK,MAAX;;;;IAIJmB,iBAAiB,CAACL,OAAD,EAAU5I,KAAV,CAAjB;IACAiI,cAAc,CAACwB,KAAD,EAAQzJ,KAAR,CAAd;;;SAGK;IACLwI,SAAS,EAATA,SADK;IAELkB,MAAM,EAAEpC,mBAAmB,CAACU,aAAD,CAFtB;IAGL2B,OAAO,EAAErC,mBAAmB,CAACW,cAAD,CAHvB;IAIL2B,MAAM,EAAEtC,mBAAmB,CAACa,aAAD,CAJtB;IAKL0B,SAAS,EAAEvC,mBAAmB,CAAC0B,gBAAD,CALzB;IAMLc,UAAU,EAAExC,mBAAmB,CAAC2B,iBAAD,CAN1B;IAOLc,SAAS,EAAEzC,mBAAmB,CAACiC,gBAAD,CAPzB;IAQLS,UAAU,EAAE1C,mBAAmB,CAACkC,iBAAD,CAR1B;IASLS,SAAS,EAAE3C,mBAAmB,CAACc,gBAAD,CATzB;IAUL8B,UAAU,EAAE5C,mBAAmB,CAACe,iBAAD;GAVjC;;;SCjJc8B,yBACdjD,UACAkD;8BAI6CrC,0BAA0B,CACrEb,QADqE;MAA/D+C,kCAAAA;MAAWC,mCAAAA;MAAY1B,kCAAAA;;WAItBR,aAAT,CAAuBF,MAAvB,EAAkC9H,KAAlC;WACSiI,cAAc,CAAC,CAACH,MAAD,CAAD,EAAW9H,KAAX,CAArB;;;WAGOiI,cAAT,CACEoC,SADF,EAEErK,KAFF;QAIM,CAACQ,KAAK,CAACC,OAAN,CAAc4J,SAAd,CAAL,EAA+B;MAC7BA,SAAS,GAAG3O,MAAM,CAACwM,MAAP,CAAcmC,SAAd,CAAZ;;;QAGIC,MAAM,GAAGD,SAAS,CAAC9B,MAAV,CACb,UAAAgC,KAAK;aAAI,EAAE1C,aAAa,CAAC0C,KAAD,EAAQrD,QAAR,CAAb,IAAkClH,KAAK,CAACoG,QAA1C,CAAJ;KADQ,CAAf;;QAIIkE,MAAM,CAACnP,MAAP,KAAkB,CAAtB,EAAyB;MACvBqP,KAAK,CAACF,MAAD,EAAStK,KAAT,CAAL;;;;WAIKmI,aAAT,CAAuBmC,MAAvB,EAA0DtK,KAA1D;QACM,CAACQ,KAAK,CAACC,OAAN,CAAc6J,MAAd,CAAL,EAA4B;MAC1BA,MAAM,GAAG5O,MAAM,CAACwM,MAAP,CAAcoC,MAAd,CAAT;;;IAEFtK,KAAK,CAACoG,QAAN,GAAiB,EAAjB;IACApG,KAAK,CAACmG,GAAN,GAAY,EAAZ;IAEA8B,cAAc,CAACqC,MAAD,EAAStK,KAAT,CAAd;;;WAGOgJ,gBAAT,CAA0BN,MAA1B,EAA6C1I,KAA7C;WACSiJ,iBAAiB,CAAC,CAACP,MAAD,CAAD,EAAW1I,KAAX,CAAxB;;;WAGOyK,gBAAT,CAA0BH,MAA1B,EAAuC5B,MAAvC,EAA0D1I,KAA1D;QACM,EAAE0I,MAAM,CAACzB,EAAP,IAAajH,KAAK,CAACoG,QAArB,CAAJ,EAAoC;aAC3B,KAAP;;;QAGIuC,QAAQ,GAAG3I,KAAK,CAACoG,QAAN,CAAesC,MAAM,CAACzB,EAAtB,CAAjB;QACM2B,OAAO,GAAGlN,MAAM,CAAC8K,MAAP,CAAc,EAAd,EAAkBmC,QAAlB,EAA4BD,MAAM,CAACG,OAAnC,CAAhB;QACMC,MAAM,GAAGjB,aAAa,CAACe,OAAD,EAAU1B,QAAV,CAA5B;WAEOlH,KAAK,CAACoG,QAAN,CAAesC,MAAM,CAACzB,EAAtB,CAAP;IAEAqD,MAAM,CAACxM,IAAP,CAAY8K,OAAZ;WAEOE,MAAM,KAAKJ,MAAM,CAACzB,EAAzB;;;WAGOgC,iBAAT,CAA2BC,OAA3B,EAAiDlJ,KAAjD;QACQsK,MAAM,GAAQ,EAApB;IAEApB,OAAO,CAAC7J,OAAR,CAAgB,UAAAqJ,MAAM;aAAI+B,gBAAgB,CAACH,MAAD,EAAS5B,MAAT,EAAiB1I,KAAjB,CAApB;KAAtB;;QAEIsK,MAAM,CAACnP,MAAP,KAAkB,CAAtB,EAAyB;MACvBqP,KAAK,CAACF,MAAD,EAAStK,KAAT,CAAL;;;;WAIKuJ,gBAAT,CAA0BzB,MAA1B,EAAqC9H,KAArC;WACSwJ,iBAAiB,CAAC,CAAC1B,MAAD,CAAD,EAAW9H,KAAX,CAAxB;;;WAGOwJ,iBAAT,CACEpD,QADF,EAEEpG,KAFF;QAIM,CAACQ,KAAK,CAACC,OAAN,CAAc2F,QAAd,CAAL,EAA8B;MAC5BA,QAAQ,GAAG1K,MAAM,CAACwM,MAAP,CAAc9B,QAAd,CAAX;;;QAGIqD,KAAK,GAAQ,EAAnB;QACMb,OAAO,GAAgB,EAA7B;;yBAEqBxC,QAArB,kHAA+B;;;;;;;;;;;;UAApB0B,MAAoB;UACvBb,EAAE,GAAGY,aAAa,CAACC,MAAD,EAASZ,QAAT,CAAxB;;UACID,EAAE,IAAIjH,KAAK,CAACoG,QAAhB,EAA0B;QACxBwC,OAAO,CAAC9K,IAAR,CAAa;UAAEmJ,EAAE,EAAFA,EAAF;UAAM4B,OAAO,EAAEf;SAA5B;OADF,MAEO;QACL2B,KAAK,CAAC3L,IAAN,CAAWgK,MAAX;;;;IAIJmB,iBAAiB,CAACL,OAAD,EAAU5I,KAAV,CAAjB;IACAiI,cAAc,CAACwB,KAAD,EAAQzJ,KAAR,CAAd;;;WAGO0K,cAAT,CAAwBC,CAAxB,EAAsCC,CAAtC;QACMD,CAAC,CAACxP,MAAF,KAAayP,CAAC,CAACzP,MAAnB,EAA2B;aAClB,KAAP;;;SAGG,IAAImE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqL,CAAC,CAACxP,MAAN,IAAgBmE,CAAC,GAAGsL,CAAC,CAACzP,MAAtC,EAA8CmE,CAAC,EAA/C,EAAmD;UAC7CqL,CAAC,CAACrL,CAAD,CAAD,KAASsL,CAAC,CAACtL,CAAD,CAAd,EAAmB;;;;aAGZ,KAAP;;;WAEK,IAAP;;;WAGOkL,KAAT,CAAeF,MAAf,EAA4BtK,KAA5B;IACEsK,MAAM,CAACF,IAAP,CAAYA,IAAZ;;IAGAE,MAAM,CAACjL,OAAP,CAAe,UAAAkL,KAAK;MAClBvK,KAAK,CAACoG,QAAN,CAAec,QAAQ,CAACqD,KAAD,CAAvB,IAAkCA,KAAlC;KADF;QAIMM,WAAW,GAAGnP,MAAM,CAACwM,MAAP,CAAclI,KAAK,CAACoG,QAApB,CAApB;IACAyE,WAAW,CAACT,IAAZ,CAAiBA,IAAjB;QAEMU,YAAY,GAAGD,WAAW,CAAC7D,GAAZ,CAAgBE,QAAhB,CAArB;QACQf,MAAQnG,MAARmG;;QAEJ,CAACuE,cAAc,CAACvE,GAAD,EAAM2E,YAAN,CAAnB,EAAwC;MACtC9K,KAAK,CAACmG,GAAN,GAAY2E,YAAZ;;;;SAIG;IACLb,SAAS,EAATA,SADK;IAELC,UAAU,EAAVA,UAFK;IAGL1B,SAAS,EAATA,SAHK;IAILkB,MAAM,EAAEpC,mBAAmB,CAACU,aAAD,CAJtB;IAKL6B,SAAS,EAAEvC,mBAAmB,CAAC0B,gBAAD,CALzB;IAMLe,SAAS,EAAEzC,mBAAmB,CAACiC,gBAAD,CANzB;IAOLK,MAAM,EAAEtC,mBAAmB,CAACa,aAAD,CAPtB;IAQLwB,OAAO,EAAErC,mBAAmB,CAACW,cAAD,CARvB;IASL6B,UAAU,EAAExC,mBAAmB,CAAC2B,iBAAD,CAT1B;IAULe,UAAU,EAAE1C,mBAAmB,CAACkC,iBAAD;GAVjC;;;AC1IF;;;;;;;AAMA,SAAgBuB,oBACdtL;MAAAA;IAAAA,UAGI;;;;IAGFuL,YAAY,EAAE;IACd9D,QAAQ,EAAE,kBAAC+D,QAAD;aAAmBA,QAAQ,CAAChE,EAA5B;;KACPxH;MAHGyH,iCAAAA;MAAU8D,qCAAAA;;MAMZE,YAAY,GAAG7E,yBAAyB,EAA9C;MACM8E,gBAAgB,GAAG1E,sBAAsB,EAA/C;MACM2E,YAAY,GAAGJ,YAAY,GAC7Bb,wBAAwB,CAACjD,QAAD,EAAW8D,YAAX,CADK,GAE7BjD,0BAA0B,CAACb,QAAD,CAF9B;;IAKEA,QAAQ,EAARA,QADF;IAEE8D,YAAY,EAAZA;KACGE,YAHL,MAIKC,gBAJL,MAKKC,YALL;;;AC9BF;AACA,AAkKA;AACA,AAAO,MAAM,eAAe,iBAAiB,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,QAAQ,KAAK,MAAM,CAAC,QAAQ,GAAG,MAAM,CAAC,iBAAiB,CAAC,CAAC,IAAI,YAAY,CAAC;AAC/J,AA2DA;AACA,AAAO,MAAM,oBAAoB,iBAAiB,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,aAAa,KAAK,MAAM,CAAC,aAAa,GAAG,MAAM,CAAC,sBAAsB,CAAC,CAAC,IAAI,iBAAiB,CAAC;AACxL,AA8UA;;AAEA,AAAO,SAAS,MAAM,CAAC,IAAI,EAAE,OAAO,EAAE;CACrC,IAAI;EACH,IAAI,MAAM,GAAG,IAAI,EAAE,CAAC;EACpB,CAAC,MAAM,CAAC,EAAE;EACV,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC;EAClB;CACD,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,EAAE;EAC1B,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC;EACpC;CACD,OAAO,MAAM,CAAC;CACd;;AC5jBD;;;AAGA,IAAIC,WAAW,GACb,kEADF;;;;;;AAOA,IAAWC,MAAM,GAAG,SAATA,MAAS,CAACC,IAAD;MAACA;IAAAA,OAAO;;;MACtBtE,EAAE,GAAG,EAAT;;MAEI3H,CAAC,GAAGiM,IAAR;;SACOjM,CAAC,EAAR,EAAY;;IAEV2H,EAAE,IAAIoE,WAAW,CAAEG,IAAI,CAACC,MAAL,KAAgB,EAAjB,GAAuB,CAAxB,CAAjB;;;SAEKxE,EAAP;CARK;;AC2BP,IAAMyE,gBAAgB,GAAiC,CACrD,MADqD,EAErD,SAFqD,EAGrD,OAHqD,EAIrD,MAJqD,CAAvD;;IAOMC,kBACJ,yBAA4BnQ,KAA5B;YAA4B,GAAAA,KAAA;;;;AAI9B,AAAO,IAAMoQ,kBAAkB,GAAG,SAArBA,kBAAqB,CAACpQ,KAAD;MAC5B,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD;QACzCqQ,WAAW,GAAoB,EAArC;;yBACuBH,gBAAvB,kHAAyC;;;;;;;;;;;;UAA9BzK,QAA8B;;UACnC,OAAOzF,KAAK,CAACyF,QAAD,CAAZ,KAA2B,QAA/B,EAAyC;QACvC4K,WAAW,CAAC5K,QAAD,CAAX,GAAwBzF,KAAK,CAACyF,QAAD,CAA7B;;;;WAIG4K,WAAP;;;SAGK;IAAEjP,OAAO,EAAEkP,MAAM,CAACtQ,KAAD;GAAxB;CAZK;;;;;;;;;;AAgLP,SAAgBuQ,iBAKdvK,MACAwK,gBAOAvM;MAIMwM,SAAS,GAAGvI,YAAY,CAC5BlC,IAAI,GAAG,YADqB,EAE5B,UAACjC,MAAD,EAAmB2M,SAAnB,EAAsCzE,GAAtC;WACS;MACL3D,OAAO,EAAEvE,MADJ;MAELwE,IAAI,EAAE;QAAE0D,GAAG,EAAHA,GAAF;QAAOyE,SAAS,EAATA;;KAFf;GAH0B,CAA9B;MAUMC,OAAO,GAAGzI,YAAY,CAC1BlC,IAAI,GAAG,UADmB,EAE1B,UAAC0K,SAAD,EAAoBzE,GAApB;WACS;MACL3D,OAAO,EAAE1I,SADJ;MAEL2I,IAAI,EAAE;QAAE0D,GAAG,EAAHA,GAAF;QAAOyE,SAAS,EAATA;;KAFf;GAHwB,CAA5B;MAUME,QAAQ,GAAG1I,YAAY,CAC3BlC,IAAI,GAAG,WADoB,EAE3B,UACEE,KADF,EAEEwK,SAFF,EAGEzE,GAHF,EAIE3D,OAJF;QAMQuI,OAAO,GAAG,CAAC,CAAC3K,KAAF,IAAWA,KAAK,CAAC0D,IAAN,KAAe,YAA1C;QACMzI,SAAS,GAAG,CAAC,CAAC+E,KAAF,IAAWA,KAAK,CAAC0D,IAAN,KAAe,gBAA5C;WACO;MACLtB,OAAO,EAAPA,OADK;MAELpC,KAAK,EAAEkK,kBAAkB,CAAClK,KAAK,IAAI,UAAV,CAFpB;MAGLqC,IAAI,EAAE;QACJ0D,GAAG,EAAHA,GADI;QAEJyE,SAAS,EAATA,SAFI;QAGJG,OAAO,EAAPA,OAHI;QAIJ1P,SAAS,EAATA;;KAPJ;GAVyB,CAA7B;MAuBI2P,gBAAgB,GAAG,KAAvB;MAEMC,EAAE,GACN,OAAOC,eAAP,KAA2B,WAA3B,GACIA,eADJ;;;;iBAGM,GAAsB;QACpBH,OAAO,EAAE,KADW;QAEpBI,gBAFoB,gCAAA;QAGpBC,aAHoB;iBAIX,KAAP;SAJkB;QAMpBC,OANoB,uBAAA;QAOpBC,mBAPoB;OAAtB;;;;;WASAC,KAZN,GAYM;MAC6C;YACrC,CAACP,gBAAL,EAAuB;UACrBA,gBAAgB,GAAG,IAAnB;UACA/P,OAAO,CAACuQ,IAAR;;;KAhBZ;;;KADF;;WA0BSlJ,aAAT,CACE6D,GADF;WAGS,UAACsF,QAAD,EAAWhN,QAAX,EAAqBiN,KAArB;UACCd,SAAS,GAAGZ,MAAM,EAAxB;UAEM2B,eAAe,GAAG,IAAIV,EAAJ,EAAxB;UACIW,WAAJ;UAEMC,cAAc,GAAG,IAAIC,OAAJ,CAAmB,UAAC7P,CAAD,EAAI8P,MAAJ;eACxCJ,eAAe,CAACK,MAAhB,CAAuBb,gBAAvB,CAAwC,OAAxC,EAAiD;iBAC/CY,MAAM,CAAC;YAAEjI,IAAI,EAAE,YAAR;YAAsBxI,OAAO,EAAEsQ,WAAW,IAAI;WAA/C,CADyC;SAAjD,CADwC;OAAnB,CAAvB;;eAMSL,KAAT,CAAeU,MAAf;QACEL,WAAW,GAAGK,MAAd;QACAN,eAAe,CAACJ,KAAhB;;;UAGIW,OAAO,GAAG;;;;;;;;gBA0CRC,YAAY,GAChBhO,OAAO,IACP,CAACA,OAAO,CAACiO,0BADT,IAEAtB,QAAQ,CAACnI,KAAT,CAAe0J,WAAf,CAFA,IAGAA,WAAW,CAAC5J,IAAZ,CAAiBpH,SAJnB;;gBAMI,CAAC8Q,YAAL,EAAmB;cACjBV,QAAQ,CAACY,WAAD,CAAR;;;mBAEKA,WAAP;;;;cAlDIA,WAAJ;;0CACI;gBAEAlO,OAAO,IACPA,OAAO,CAAC9C,SADR,IAEA8C,OAAO,CAAC9C,SAAR,CAAkB8K,GAAlB,EAAuB;cAAE1H,QAAQ,EAARA,QAAF;cAAYiN,KAAK,EAALA;aAAnC,MAAgD,KAHlD,EAIE;oBACM;gBACJ5H,IAAI,EAAE,gBADF;gBAEJxI,OAAO,EAAE;eAFX;;;YAKFmQ,QAAQ,CAACZ,OAAO,CAACD,SAAD,EAAYzE,GAAZ,CAAR,CAAR;mCACoB2F,OAAO,CAACQ,IAAR,CAAa,CAC/BT,cAD+B,EAE/BC,OAAO,CAACS,OAAR,CACE7B,cAAc,CAACvE,GAAD,EAAM;cAClBsF,QAAQ,EAARA,QADkB;cAElBhN,QAAQ,EAARA,QAFkB;cAGlBiN,KAAK,EAALA,KAHkB;cAIlBd,SAAS,EAATA,SAJkB;cAKlBoB,MAAM,EAAEL,eAAe,CAACK,MALN;cAMlBQ,eANkB,2BAMFtS,KANE;uBAOT,IAAImQ,eAAJ,CAAoBnQ,KAApB,CAAP;;aAPU,CADhB,EAWEuS,IAXF,CAWO,UAAAxO,MAAM;kBACPA,MAAM,YAAYoM,eAAtB,EAAuC;uBAC9BS,QAAQ,CAAC,IAAD,EAAOF,SAAP,EAAkBzE,GAAlB,EAAuBlI,MAAM,CAAC/D,KAA9B,CAAf;;;qBAEKyQ,SAAS,CAAC1M,MAAD,EAAS2M,SAAT,EAAoBzE,GAApB,CAAhB;aAfF,CAF+B,CAAb,CAZlB;cAYFkG,WAAW,gBAAX;;uBAoBOK,KAAK;YACZL,WAAW,GAAGvB,QAAQ,CAAC4B,GAAD,EAAM9B,SAAN,EAAiBzE,GAAjB,CAAtB;;;;SAnCY;;;SAAhB;;aAqDO/L,MAAM,CAAC8K,MAAP,CAAcgH,OAAd,EAAuB;QAAEX,KAAK,EAALA;OAAzB,CAAP;KAtEF;;;SA0EKnR,MAAM,CAAC8K,MAAP,CACL5C,aADK,EAML;IACEuI,OAAO,EAAPA,OADF;IAEEC,QAAQ,EAARA,QAFF;IAGEH,SAAS,EAATA;GATG,CAAP;;;;;;AA0BF,SAAgBgC,aACdC;MAEI,WAAWA,QAAf,EAAyB;UACjBA,QAAQ,CAACxM,KAAf;;;SAEMwM,QAAgB,CAACpK,OAAzB;;;ACzZF;;;;AAGAqK,yBAAS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}